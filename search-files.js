(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{49:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var o=[{id:"pages/generated/info.md",body:"# `info`\n\nDetermine the environment, check if auto is set up correctly, and list plugins.\n\n## Options\n\n| Flag | Type | Description |\n| - | - | - |\n| `--list-plugins` | Boolean | List the available plugins |\n\n## Examples\n\n```sh\nauto info\n```\n\n"},{id:"../plugins/upload-assets/README.md",body:'# Upload Assets Plugin\n\nUpload assets to the release. Good for executables and extra downloadable files.\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/upload-assets\n# or\nyarn add -D @auto-it/upload-assets\n```\n\n## Usage\n\nSimply supply the paths to the assets to add to the release.\n\n```json\n{\n  "plugins": [\n    ["upload-assets", { "assets": ["./path/to/file"] }],\n    // or\n    ["upload-assets", ["./path/to/file"]],\n    // or use globs to upload multiple things\n    ["upload-assets", ["./path/**/to/*.file"]]\n  ]\n}\n```\n'},{id:"../plugins/twitter/README.md",body:'# Twitter Plugin\n\nPost tweets after a release is made.\n\n## Prerequisites\n\nTo post tweets to twitter you need the following secrets set in your environment:\n\n- `TWITTER_ACCESS_TOKEN`\n- `TWITTER_ACCESS_TOKEN_SECRET`\n- `TWITTER_CONSUMER_KEY`\n- `TWITTER_CONSUMER_KEY_SECRET`\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/twitter\n# or\nyarn add -D @auto-it/twitter\n```\n\n## Usage\n\nSimply supply the names of the account to filter\n\n```json\n{\n  "plugins": [\n    [\n      "twitter",\n      {\n        /* options */\n      }\n    ]\n  ]\n}\n```\n\n## Options\n\n### Message\n\nYou can configure the message posted to twitter. The `message` option should use the following special tokens to create a tweet.\n\n- `%release` - The version bump (major, minor, patch)\n- `%package` - The name of the package\n- `%notes` - Your release notes truncated to fit in the tweet\n- `%link` - A link to your the release on GitHub\n- `%version` - The latest version number\n\nDefault:\n\n```txt\nA new %release version of %package was released!\n\n%notes\n\n%link\n```\n\n```json\n{\n  "plugins": [\n    ["twitter", { "message": "v%version of %package was released!\\n\\n%link" }]\n  ]\n}\n```\n\n### Threshold\n\nBy default the `twitter` plugin will only tweet if the version difference between the latest and the last release is greater than a `minor`.\n\n```json\n{\n  "plugins": [["twitter", { "threshold": "major" }]]\n}\n```\n'},{id:"../plugins/slack/README.md",body:'# Slack Plugin\n\nPost your release notes to a slack channel\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/slack\n# or\nyarn add -D @auto-it/slack\n```\n\n## Usage\n\nTo use the plugin include it in your `.autorc`.\n\n```json\n{\n  "plugins": [\n    // or\n    ["slack", { "url": "https://url-to-your-slack-hook.com" }],\n    // or\n    ["slack", "https://url-to-your-slack-hook.com"],\n    // or\n    [\n      "slack",\n      { "url": "https://url-to-your-slack-hook.com", "atTarget": "here" }\n    ],\n    // Below: Uses slack hook set in process.env.SLACK_WEBHOOK_URL\n    "slack"\n  ]\n}\n```\n\nThis URL should be to you webhook. Store it in `SLACK_WEBHOOK_URL` for more security. If you require a token to post to a slack hook, make sure you have a `SLACK_TOKEN` variable available on your environment. This token will be added to eh URL as a query string parameter.\n\n### Next\n\nIf you are using a `prerelease` branch like `next`, Slack will not post a message by default. This is done to avoid spamming your consumers every time you make a preview release. However, if you would like to configure it such that Slack _does_ post on prerelease, you can add the `publishPreRelease` to your `.autorc` like so:\n\n```json\n{\n  "plugins": [\n    [\n      "slack",\n      { "url": "https://url-to-your-slack-hook.com", "publishPreRelease": true }\n    ],\n    // or\n    ["slack", "https://url-to-your-slack-hook.com"],\n    // or\n    [\n      "slack",\n      {\n        "url": "https://url-to-your-slack-hook.com",\n        "atTarget": "here",\n        "publishPreRelease": true\n      }\n    ]\n  ]\n}\n```\n'},{id:"../plugins/released/README.md",body:'# Released Plugin\n\nThis plugin\n\n- comments on the merged PR with the new version\n- comments on closed issues with the new version\n- adds a `released` label to the pull request\n- adds a `released` label to closed issues\n\n::: message is-warning\nMake sure that you create the `released` label on you project\n:::\n\n## Installation\n\nThis plugin is included with the `auto` CLI so you do not have to install it. To install if you are using the `auto` API directly:\n\n```sh\nnpm i --save-dev @auto-it/released\n# or\nyarn add -D @auto-it/released\n```\n\n## Usage\n\nTo use the plugin include it in your `.autorc`\n\n```json\n{\n  "plugins": ["released"]\n}\n```\n\n## Options\n\n### Label\n\nCustomize the label this plugin attaches to merged pull requests.\n\n```json\n{\n  "plugins": [\n    [\n      "released",\n      {\n        "label": ":shipit:"\n      }\n    ]\n  ]\n}\n```\n\n### Prerelease Label\n\nCustomize the prerelease label this plugin attaches to pull requests merged to prerelease branches.\n\n```json\n{\n  "plugins": [\n    [\n      "released",\n      {\n        "prereleaseLabel": "ðŸš§"\n      }\n    ]\n  ]\n}\n```\n\n### Message\n\nTo customize the message this plugin uses on issues and pull requests use the following format.\n\n- `%TYPE` - Either `PR` or `Issue`\n- `%VERSION` - The version that was just published\n\n```json\n{\n  "plugins": [\n    [\n      "released",\n      {\n        "message": "%TYPE went out with version: %VERSION"\n      }\n    ]\n  ]\n}\n```\n\n### Lock Issue\n\nLock issues that have been merged in PRs.\n\n```json\n{\n  "plugins": [["released", { "lockIssues": true }]]\n}\n```\n'},{id:"../plugins/omit-release-notes/README.md",body:'# Omit Release Notes Plugin\n\nFilter PRs with release notes that shouldn\'t make it into a release. By default `auto` will not include and `Release Notes` from [renovate](https://renovatebot.com/) PRs. This plugin allows you to omit more PRs from effecting you releases.\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/omit-release-notes\n# or\nyarn add -D @auto-it/omit-release-notes\n```\n\n## Usage\n\nYarn can omit by most any field available on a PR. Each options accepts either a string or an array of strings.\n\n```json\n{\n  "plugins": [\n    [\n      "omit-release-notes",\n      {\n        // By usernames\n        "username": ["pdbf", "ghost"],\n        // By name\n        "name": "Adam",\n        // By emails\n        "email": ["foo@gmail.com", "doesnt-exits@yahoo.com"],\n        // By labels\n        "labels": "grunt-work"\n      }\n    ]\n  ]\n}\n```\n'},{id:"../plugins/omit-commits/README.md",body:'# Omit Commits Plugin\n\nFilter certain commits out of the changelog and version calculation.\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/omit-commits\n# or\nyarn add -D @auto-it/omit-commits\n```\n\n## Usage\n\nYarn can omit by most any field available on a commit. Each options accepts either a string or an array of strings.\n\n```jsonc\n{\n  "plugins": [\n    [\n      "omit-commits",\n      {\n        // By usernames\n        "username": ["pdbf", "ghost"],\n        // By name\n        "name": "Adam",\n        // By emails\n        "email": ["foo@gmail.com", "doesnt-exits@yahoo.com"],\n        // By presence of string in subject\n        "subject": ["WIP", "SPIKE"],\n        // By labels\n        "labels": "grunt-work"\n      }\n    ]\n  ]\n}\n```\n'},{id:"../plugins/jira/README.md",body:'# Jira Plugin\n\nTo include Jira story information in your changelogs you must include a URL to your hosted JIRA instance.\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/jira\n# or\nyarn add -D @auto-it/jira\n```\n\n## Usage\n\nTo use the plugin include it in your `.autorc`\n\n```json\n{\n  "plugins": [\n    ["jira", { "url": "https://url-to-your-jira.com" }],\n    // or\n    ["jira", "https://url-to-your-jira.com"]\n  ]\n}\n```\n'},{id:"../plugins/gh-pages/README.md",body:'# GitHub Pages Plugin\n\nAutomate publishing to your gh-pages documentation website\n\n`auto` will push a directory to your `gh-pages` branch:\n\n1. on every release\n2. if the `documentation` label is on the pull request\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/gh-pages\n# or\nyarn add -D @auto-it/gh-pages\n```\n\n## Usage\n\nAll you need to do a provide that path to your build documentation website.\n\n```json\n{\n  "plugins": [\n    ["gh-pages", { "dir": "./path/to/built/docs/website" }]\n    // other plugins\n  ]\n}\n```\n\n### Build Your Docs\n\nIf you also want `auto` to run the build for you docs site provide the `buildCommand` option.\n\n```json\n{\n  "plugins": [\n    [\n      "gh-pages",\n      {\n        "buildCommand": "npm run build:docs",\n        "dir": "./path/to/built/docs/website"\n      }\n    ]\n    // other plugins\n  ]\n}\n```\n\n### Pages Branch\n\nYou can configure the branch `auto` pushes to with the `branch` option.\n\n```json\n{\n  "plugins": [\n    [\n      "gh-pages",\n      {\n        "branch": "docs",\n        "dir": "./path/to/built/docs/website"\n      }\n    ]\n    // other plugins\n  ]\n}\n```\n\n### Documentation Label\n\nYou can configure the label `auto` looks for with the `label` option.\n\n```json\n{\n  "plugins": [\n    [\n      "gh-pages",\n      {\n        "label": "website",\n        "dir": "./path/to/built/docs/website"\n      }\n    ]\n    // other plugins\n  ]\n}\n```\n'},{id:"../plugins/first-time-contributor/README.md",body:'# First Time Contributor Plugin\n\nThank first time contributors for their work right in your release notes.\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/first-time-contributor\n# or\nyarn add -D @auto-it/first-time-contributor\n```\n\n## Usage\n\nSimply add the plugins to your auto configuration.\n\n```json\n{\n  "plugins": ["first-time-contributor"]\n}\n```\n'},{id:"../plugins/exec/README.md",body:'# Exec Plugin\n\nTap into hooks and run scripts on the terminal.\n\nMain hooks, in call order:\n\n- beforeRun\n- getRepository\n- getAuthor\n- beforeShipIt\n- getPreviousVersion\n- afterAddToChangelog\n- beforeCommitChangelog\n- version\n- afterVersion\n- publish\n- afterPublish\n- afterRelease\n- afterShipIt\n\nOther hooks:\n\n- canary\n- next\n- modifyConfig\n- makeRelease\n- onCreateLogParse\n  - parseCommit\n  - omitCommit\n- onCreateChangelog\n  - renderChangelogLine\n  - renderChangelogTitle\n  - renderChangelogAuthor\n  - renderChangelogAuthorLine\n  - omitReleaseNotes\n- onCreateRelease\n  - createChangelogTitle\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/exec\n# or\nyarn add -D @auto-it/exec\n```\n\n## Usage\n\nHere is an example of replacing the `npm` plugins with a light-weight version.\n\nAll args to a hook are exposed on the process in environment variables.\nThe format looks like `$ARG_0`, `$ARG_1`, and so on.\nPlease look at the docs for [writing plugins](/auto/pages/writing-plugins.html) for more detail on what\'s available.\n\n```json\n{\n  "plugins": [\n    [\n      "exec",\n      {\n        "version": "npm version $ARG_0",\n        "publish": "npm publish && git push --tags",\n        "afterRelease": "yarn docs && push-dir --dir=docs --branch=gh-pages"\n      }\n    ]\n    // other plugins\n  ]\n}\n```\n\n::: message is-warning\n:warning: If you are tapping into a waterfall or bail hook you will need to return some value (ex: JSON or a boolean). Please refer to the documentation and return the right thing!\n:::\n'},{id:"../plugins/conventional-commits/README.md",body:'# Conventional Commits Plugin\n\nParse [conventional commit messages](https://www.conventionalcommits.org/en/v1.0.0-beta.4/) and use them to calculate the version. This plugin will omit the PR HEAD if it isn\'t labeled and has a commit with a conventional-commit commit message.\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/conventional-commits\n# or\nyarn add -D @auto-it/conventional-commits\n```\n\n## Usage\n\n```json\n{\n  "plugins": [\n    "npm",\n    "conventional-commits"\n    // other plugins\n  ]\n}\n```\n'},{id:"../plugins/s3/README.md",body:'# S3 Plugin\n\nPost your built artifacts to s3.\n\n## Prerequisites\n\nMust have the [aws-cli](https://docs.aws.amazon.com/cli/index.html) on your machine and all of the following environment variables set:\n\n- `AWS_ACCESS_KEY`\n- `AWS_SECRET_KEY`\n- `AWS_SESSION_TOKEN`\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/s3\n# or\nyarn add -D @auto-it/s3\n```\n\n## Usage\n\nPublish a single asset to s3.\n\n`bucket`: Bucket to deploy to\n`region`: Region to deploy to\n`files`: An array of tuples mapping local build files to remote deploy paths.\n\n```txt\nEX:\n\ngiven: `[["components/button/dist", "components/button"]]`\n\n=> Deploy the files in "components/button/dist" to s3://bucket/components/button on `region`\n```\n\n**Full**:\n\n```json\n{\n  "plugins": [\n    [\n      "s3",\n      {\n        "bucket": "BUCKET_NAME",\n        "region": "REGION_NAME",\n        "files": [["components/button/dist", "components/button"]]\n      }\n    ]\n    // other plugins\n  ]\n}\n```\n\n### Versioning Deploys\n\nTo version your deployed assets simply add `$VERSION` in the `remote` path. This will be replaced with the new version being released.\n\n```json\n{\n  "plugins": [\n    [\n      "s3",\n      {\n        "bucket": "BUCKET_NAME",\n        "region": "REGION_NAME",\n        "files": [["components/button/dist", "$VERSION/components/button"]]\n      }\n    ]\n    // other plugins\n  ]\n}\n```\n\n### Multiple Files\n\nPublish multiple assets to s3.\n\n```json\n{\n  "plugins": [\n    [\n      "s3",\n      {\n        "bucket": "BUCKET_NAME",\n        "region": "REGION_NAME",\n        "files": [\n          ["components/button/dist", "components/button"],\n          ["components/card/dist", "components/card"],\n          ["components/select/dist", "components/select"]\n        ]\n      }\n    ]\n  ]\n}\n```\n\n### Multiple Buckets\n\nPublish assets to multiple s3 buckets.\n\n```json\n{\n  "plugins": [\n    [\n      "s3",\n      [\n        {\n          "bucket": "BUCKET_NAME",\n          "region": "REGION_NAME",\n          "files": [["components/button/dist", "components/button"]]\n        },\n        {\n          "bucket": "ANOTHER_BUCKET_NAME",\n          "region": "REGION_NAME",\n          "files": [["components/card/dist", "components/card"]]\n        }\n      ]\n    ]\n  ]\n}\n```\n\n### Overwrite\n\nBy default this plugin will overwrite any bucket path you give it. To prevent it from overwriting your bucket path if it already exists set `overwrite` to false\n\n```json\n{\n  "plugins": [\n    [\n      "s3",\n      {\n        "bucket": "BUCKET_NAME",\n        "region": "REGION_NAME",\n        "overwrite": false,\n        ...\n      }\n    ]\n  ]\n}\n```\n'},{id:"../plugins/all-contributors/README.md",body:'# All Contributors Plugin\n\nAutomatically add contributors as changelogs are produced.\n\nThis plugin maps one of the [contribution type](vhttps://allcontributors.org/docs/en/emoji-key) to a glob or array of globs.\nOut of the box the plugin will only detect the following contribution types:\n\n- ðŸ“– `doc` - Edits to any README `[\'**/*.mdx\', \'**/*.md\', \'**/docs/**/*\', \'**/documentation/**/*\']`\n- ðŸ’¡ `example` - Edits to `[\'**/*.stories*\', \'**/*.story.*\']`\n- ðŸš‡ `infra` - Edits to `[\'**/.circle/**/*\', \'**/.github/**/*\', \'**/travis.yml\'],`\n- âš ï¸ `test` - Edits to `[\'**/*.test.*\']`\n- ðŸ’» `code` - Edits to `[\'**/src/**/*\', \'**/lib/**/*\', \'**/package.json\', \'**/tsconfig.json\']`\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/all-contributors all-contributors-cli\n# or\nyarn add -D @auto-it/all-contributors all-contributors-cli\n```\n\n## Prerequisites\n\n```sh\nnpx all-contributors init\n```\n\n## Usage\n\n```json\n{\n  "plugins": ["all-contributors"]\n}\n```\n\n### Configure Contribution Type Matching\n\nYou use any of the [contribution type](vhttps://allcontributors.org/docs/en/emoji-key).\nIf you configure an pre-configured contribution type the arrays are not merged, it is overridden.\n\n**`auto.rc`**\n\n```json\n{\n  "plugins": [\n    [\n      "all-contributors",\n      {\n        "types": {\n          "plugin": "**/plugin/**/*",\n          "example": ["**/*.stories.*", "**/*.examples.*", "**/*.snippet.*"]\n        }\n      }\n    ]\n  ]\n}\n```\n\n### Adding Non-Code Contributions\n\nSometimes you worked with a person that didn\'t touch the code personally so this plugin would never attribute them with any contributions.\nSince these contributions cannot be automated you can instead just list out another contributor\'s (name + GitHub username) contributions directly in the PR.\n\nAdd the following to a PR body and auto will try to parse it and add contributors from it.\n\n```md\n# Contributions\n\n- Some Guy (@some_guy) - design, doc\n```\n\nTo ensure you are doing it right `auto` will comment on the PR with the people + contributions you are manually adding.\n\n### Exclude Users\n\nUseful for excluding bots from getting into your contributors.\n\n**`auto.rc`**\n\n```json\n{\n  "plugins": [\n    [\n      "all-contributors",\n      {\n        "exclude": ["dependabot", "ci-services"]\n      }\n    ]\n  ]\n}\n```\n\n### Sub-Package Contributors list\n\nMaintain contributors lists for sub-packages in a monorepo setup (`lerna`/`yarn`).\n\nAll you need to do is initialize each sub-package you want contributors tracked in with an `.all-contributorsrc`. If no rc file is found nothing will happen for that package. Any non-code contribution listed in the PR body will also be added to the sub-package contributors list.\n\n```sh\ncd packages/your-package\nnpx all-contributors init\n```\n\n::: message is-info\nâ„¹ï¸ Tip: If you only want 1 commit for new contributions set `commit` to false in all of your `.all-contributorsrc`. Otherwise a commit will be made for each package\'s contributor update.\n:::\n'},{id:"../plugins/npm/README.md",body:'# NPM Plugin\n\nPublish to NPM. Works in both a monorepo setting and for a single package. This plugin is loaded by default when `auto` is installed through `npm`. If you configure `auto` to use any other plugin this will be lost. So you must add the `npm` plugin to your plugins array if you still want NPM functionality.\n\n## Prerequisites\n\nTo publish to npm you will need an `NPM_TOKEN` set in your environment.\n\n## Installation\n\nThis plugin is included with the `auto` CLI so you do not have to install it. To install if you are using the `auto` API directly:\n\n```sh\nnpm i --save-dev @auto-it/npm\n# or\nyarn add -D @auto-it/npm\n```\n\n## Usage\n\n```json\n{\n  "plugins": [\n    "npm",\n    // or with options\n    ["npm", { "forcePublish": false }]\n    // other plugins\n  ]\n}\n```\n\n> If you\'re using the `noVersionPrefix` option you will also need to add `tag-version-prefix=""` to your `.npmrc`.\n> Otherwise when npm versions your code the tag it creates will have the `v` and `auto` will get confused.\n\n## Monorepo Usage\n\nThe `npm` plugin works out of the box with `lerna` in both [`independent`](https://github.com/lerna/lerna#independent-mode) and [`fixed`](https://github.com/lerna/lerna#fixedlocked-mode-default) mode. `auto` works on a repo basis and should be run from the root of the repo, not on each sub-package. No additional setup is required.\n\n## Options\n\n### setRcToken\n\nWhen running the `shipit` command auto will try to set your `.npmrc` token while publishing. To disable this feature you must set the `setRcToken` to false.\n\n```json\n{\n  "plugins": [\n    [\n      "npm",\n      {\n        "setRcToken": false\n      }\n    ]\n  ]\n}\n```\n\n### forcePublish\n\nBy default `auto` will force publish all packages for monorepos. To disable this behavior you must set the `setRcToken` to false.\n\n```json\n{\n  "plugins": [\n    [\n      "npm",\n      {\n        "forcePublish": false\n      }\n    ]\n  ]\n}\n```\n\n### exact\n\nTo force all packages publish with [exact versions](https://github.com/lerna/lerna/blob/master/commands/version/README.md#--exact).\n\n```json\n{\n  "plugins": [\n    [\n      "npm",\n      {\n        "exact": true\n      }\n    ]\n  ]\n}\n```\n\n### subPackageChangelogs\n\n`auto` will create a changelog for each sub-package in a monorepo.\nYou can disable this behavior by using the `subPackageChangelogs` option.\n\n```json\n{\n  "plugins": [\n    [\n      "npm",\n      {\n        "subPackageChangelogs": false\n      }\n    ]\n  ]\n}\n```\n\n### canaryScope\n\nPublishing canary versions comes with some security risks.\nIf your project is private you have nothing to worry about and can skip these, but if your project is open source there are some security holes.\n\n::: message is-warning\nThis feature works pretty easily/well for single packages. In a monorepo we have to deal with a lot more, and this options should be treated as experimental.\n:::\n\n#### Setup\n\n1. Create a test scope that you publish canaries under (ex: `@auto-canary` or `@auto-test`)\n2. Create a user that only has access to that scope\n3. Set the default `NPM_TOKEN` to a token that can publish to that scope (this is used for any pull request)\n4. Set up a `secure` token that is only accessible on the main fork (still named `NPM_TOKEN`)\n5. Set up alias (only monorepos)\n\nStep 3 might not be possible on your build platform.\n\nThe following are the ways the `auto` team knows how to do it.\nIf you do not see the method for you build platform, please make a pull request!\n\n**Platform Solutions:**\n\n- [CircleCI Context](https://circleci.com/docs/2.0/contexts/) - Contexts provide a mechanism for securing and sharing environment variables across projects. The environment variables are defined as name/value pairs and are injected at runtime.\n\n```json\n{\n  "plugins": [\n    [\n      "npm",\n      {\n        "canaryScope": "@auto-canary"\n      }\n    ]\n  ]\n}\n```\n\n##### Set up alias\n\nIf you are managing a non-monorepo you do not have to do anything for this step!\nIf you manage a monorepo we still have to do handle our packages importing each other.\nSince we just changed the name of the package all imports to our packages are now broken!\n\nThere are multiple ways to make this work and the solution might be different depending on your build target.\n\n- [module-alias](https://www.npmjs.com/package/module-alias) - Modifiy node\'s require for your canary deploys (This is what `auto` uses). Useful for node packages\n- [Webpack Aliases](https://webpack.js.org/configuration/resolve/) Modify scoped requires for webpack based projects.\n- [babel-plugin-module-resolver](https://www.npmjs.com/package/babel-plugin-module-resolver) - A Babel plugin to add a new resolver for your modules when compiling your code using Babel.\n\n## Troubleshooting\n\n## npm ERR! need auth auth required for publishing\n\nThis error will occur when you do not have a `NPM_TOKEN` set.\n\n### Still getting errors?!\n\nMake sure that `npm` is trying to publish to the correct registry. Force `npm`/`lerna` to use the public registry by adding the following to your package.json:\n\n```json\n{\n  "publishConfig": {\n    "registry": "https://registry.npmjs.org/",\n    "access": "public"\n  }\n}\n```\n'},{id:"../plugins/maven/README.md",body:'# Maven Plugin\n\nRelease a Java project to a [maven](https://maven.apache.org/) instance.\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/maven\n# or\nyarn add -D @auto-it/maven\n```\n\n## Usage\n\n```json\n{\n  "plugins": ["maven"]\n}\n```\n\n## Maven Project Configuration\n\nYour project must be using the maven release plugin. Make sure the the latest `maven-release-plugin` is in your `pom.xml`.\n\n```xml\n<plugin>\n  <groupId>org.apache.maven.plugins</groupId>\n  <artifactId>maven-release-plugin</artifactId>\n  <version>3.0.0-M1</version>\n  <configuration>\n    <preparationGoals>initialize</preparationGoals>\n    <goals>deploy</goals>\n  </configuration>\n</plugin\n```\n\nYou will also need all of the following configuration blocks for all parts of `auto` to function:\n\n1. Author\n\n   ```xml\n   <developers>\n     <developer>\n       <name>Andrew Lisowski</name>\n       <email>test@email.com</email>\n     </developer>\n   </developers>\n   ```\n\n2. SCM\n\n   ```xml\n   <scm>\n     <connection>scm:git:https://${env.GH_USER}:${env.GH_TOKEN}@github.com/Fuego-Tools/java-test-project.git</connection>\n     <developerConnection>scm:git:https://${env.GH_USER}:${env.GH_TOKEN}@github.com/Fuego-Tools/java-test-project.git</developerConnection>\n     <url>https://github.com/Fuego-Tools/java-test-project</url>\n     <tag>HEAD</tag>\n   </scm>\n   ```\n\n   ::: message is-info\n   Don\'t forget to set enviornment variables `GH_USER`, `GH_TOKEN`\n   :::\n\n3. Version\n\n   ```xml\n   <version>1.0.0-SNAPSHOT</version>\n   ```\n'},{id:"../plugins/gradle/README.md",body:'# Gradle Plugin\n\nRelease a Java project using [gradle](https://gradle.org/).\n\n- supports both `-snapshot` and `-snapshot`-less versioning\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/gradle\n# or\nyarn add -D @auto-it/gradle\n```\n\n## Usage\n\n```jsonc\n{\n  "plugins": [\n    [\n      "gradle",\n      {\n        // An optional gradle binary cmd/path relative to your project\n        // @default /usr/bin/gradle\n        "gradleCommand": "./gradlew",\n\n        // An optional gradle argument list -- IE any gradle option allowed for the version\n        // of gradle you\'re using\n        // @default []\n        "gradleOptions": ["-P someProp=someVal"]\n      }\n    ]\n    // other plugins\n  ]\n}\n```\n\n## Gradle Project Configuration\n\nThis plugin uses the (gradle release plugin)[https://github.com/researchgate/gradle-release] to update the version. Make sure the the latest `gradle-release-plugin` is in your `build.gradle`.\n\n```groovy\nplugins {\n  id \'net.researchgate.release\' version \'2.6.0\' // gradle release plugin\n}\n```\n\n### Publish\n\nThis plugin will also call the `publish` task with the release version, if configured in your project.\n\n### Configure `snapshotSuffix`\n\nThis plugin will use the `snapshotSuffix` in `gradle.properties` or `build.gradle` if configured.\n\n### Build After Version Bump Automatically\n\nThis plugin will run a release build to create release artifacts.\n'},{id:"../plugins/git-tag/README.md",body:'# Git Tag Plugin\n\nManage your projects version through just a git tag. This plugin is loaded by default when `auto` is installed through the binaries released on GitHub.\n\nIf you\'re using this plugin you aren\'t releasing your code to any platform (npm, maven, etc). Instead you version calculations is done entirely though git tags.\n\nThis plugin only:\n\n1. gets last git tag\n2. bump it to new version\n3. create new tags\n4. push to github\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/git-tag\n# or\nyarn add -D @auto-it/git-tag\n```\n\n## Usage\n\nSimply add the plugins to your auto configuration.\n\n```json\n{\n  "plugins": ["git-tag"]\n}\n```\n'},{id:"../plugins/cocoapods/README.md",body:'# CocoaPods Plugin\n\nUse `auto` to version your [CocoaPod](https://cocoapods.org/), and push to your specs repository!\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/cocoapods\n# or\nyarn add -D @auto-it/cocoapods\n```\n\n## Usage\n\n```jsonc\n{\n  "plugins": [\n    [\n      "cocoapods",\n      {\n        // Required, the relative path to your podspec file\n        "podspecPath": "./Test.podspec",\n        // Optional, the specs repo to push to\n        "specsRepo": "https://github.com/intuit/TestSpecs.git"\n      }\n    ]\n    // other plugins\n  ]\n}\n```\n\n## Requirements\n\n### General\n\n- The machine running this plugin must have the [CocoaPods](https://cocoapods.org/) `pod` CLI installed already.\n\n- Your `podspec` file must pass `pod lib lint` in order for publishing to a Specs repository to work.\n\n### Pushing to the CocoaPods Trunk\n\nIf a `specsRepo` is not provided in the plugin options, this plugin will push to the CocoaPods trunk repository. This requires that the machine running this has followed the steps for pushing to trunk, the guide for that can be found [here](https://guides.cocoapods.org/making/getting-setup-with-trunk.html#getting-started).\n\n### Pushing to a private specs repo\n\nIf `specsRepo` is provided in the configuration, this plugin will add that repo under a temporary name, push to it, and remove the repo from the CocoaPods installation on the machine. The machine that is running the plugin must have the appropriate git credentials to push to that repository.\n'},{id:"../plugins/crates/README.md",body:'# Crates Plugin\n\nDeploy Rust crates to [crates.io](https://crates.io/).\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/crates\n# or\nyarn add -D @auto-it/crates\n```\n\n## Usage\n\n```json\n{\n  "plugins": ["crates"]\n}\n```\n\n## Crates Project Configuration\n\nThis plugin handles incrementing the crate version, but it requires that your crate be ready for publishing. You can view [the publishing reference](https://doc.rust-lang.org/cargo/reference/publishing.html) for more information on that process.\n\nWhen ran on a machine with `~/cargo/credentials`, that file will automatically be used by Cargo. For machines that do not have this file (like CI builds), the `CARGO_REGISTRY_TOKEN` environment variable is expected for Cargo\'s publish command as per the [publish options](https://doc.rust-lang.org/cargo/commands/cargo-publish.html#cargo_publish_options).\n'},{id:"../plugins/chrome/README.md",body:'# Chrome Web Store\n\nThis plugin allows you to automate the publishing of chrome extensions\n\n::: message is-success\nExample Repo: [here](https://github.com/hipstersmoothie/auto-chrome)\n:::\n\n## Prerequisites\n\nTo publish to the chrome web store you will need the following secrets set in your environment. See [here](https://github.com/DrewML/chrome-webstore-upload/blob/master/How%20to%20generate%20Google%20API%20keys.md) for a guide one how to get these values.\n\n- `CLIENT_ID`\n- `CLIENT_SECRET`\n- `REFRESH_TOKEN`\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/chrome\n# or\nyarn add -D @auto-it/chrome\n```\n\n## Usage\n\nYou must first pack/zip your plugin before running `auto`.\n\nThese environment variables tell `auto` what to publish.\n\n- EXTENSION_ID - your chrome extensions unique ID (REQUIRED)\n- EXTENSION_BUILD - Path to either a zip file, or a directory to be zip. defaults to `extension.zip`\n\nOr you can set these values in the autorc:\n\n```json\n{\n  "plugins": [\n    [\n      "chrome",\n      {\n        "id": "1234",\n        "build": "path/to/zip/or/folder",\n        "manifest": "path/tp/manifest.json"\n      }\n    ]\n  ]\n}\n```\n\n::: message is-warning\n:warning: You must have a manifest.json for this plugin to work.\n:::\n'},{id:"../plugins/brew/README.md",body:'# Brew Plugin\n\nAutomate the creation of Homebrew formulae.\nThis plugin can be use with any other package manager plugin.\n\n> NOTE: This plugin does not work in `lerna` monorepos that use `independent` versioning.\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/brew\n# or\nyarn add -D @auto-it/brew\n```\n\n## Usage\n\nTo use this plugin you will need to add the required configuration and a template file.\n\n- `executable` - REQUIRED: The executable to create a formula for\n- `name` - REQUIRED: The name of the formula to create\n- `formula` - A path to the formula template. Default is \'./formula-template.rb\'\n\n```json\n{\n  "plugins": [\n    [\n      "brew",\n      {\n        "executable": "path/to/some/executable",\n        "name": "name-of-formula",\n        "formula": "path/to/formula/template"\n      }\n    ]\n  ]\n}\n```\n\nCreate a template name `./formula-template.rb` at the root of the project (or use the `formula` option to customize the location)/\nThe template file must be a valid homebrew ruby file.\n\n`auto` will replace the following tokens in the template file:\n\n- `$VERSION` - The version being published\n- `$SHA` - The sha of the executable being included in the formula\n\nHere is the template `auto` uses to publish it\'s own `brew` formula:\n\n```ruby\nclass Auto < Formula\n  desc "Generate releases based on semantic version labels on pull requests."\n  homepage "https://intuit.github.io/auto/home.html"\n  url "https://github.com/intuit/auto/releases/download/$VERSION/auto-macos.gz"\n  version "$VERSION"\n  sha256 "$SHA"\n\n  def install\n    libexec.install Dir["*"]\n    bin.install libexec/"auto-macos"\n    mv bin/"auto-macos", bin/"auto"\n  end\n\n  test do\n    system bin/"auto", "--version"\n  end\nend\n```\n\n### Multiple Formulae\n\nYou can also use this to create multiple `brew` formulae.\n\n```json\n{\n  "plugins": [\n    [\n      "brew",\n      [\n        {\n          "executable": "path/to/some/executable",\n          "name": "name-of-formula",\n          "formula": "path/to/formula/template"\n        },\n        {\n          "executable": "path/to/another/executable",\n          "name": "another-formula",\n          "formula": "path/to/formula/another"\n        }\n      ]\n    ]\n  ]\n}\n```\n'},{id:"pages/build-platforms/travis.md",body:'# Travis CI\n\nThe following config declares the `deploy` job that run on all branches. The job will either release:\n\n- a new `latest` version from `master`\n- a `canary` build from a pull request (if your package manager plugin implements them)\n\n**`.travis.yml`**\n\n```yaml\nlanguage: node_js\nnode_js: "10"\n\ngit:\n  depth: false\n\nscript:\n  - yarn lint\n  - yarn test\n  - yarn build\n\ndeploy:\n  - provider: script\n    script: if [ "$GH_TOKEN" != "false" ];then npx auto shipit; fi;\n    skip-cleanup: true\n    on:\n      all_branches: true\n```\n\n## Troubleshooting\n\nIf you are having problems make sure you have done the following:\n\n- `GH_TOKEN` is set\n- Any other secrets for plugins are set (Ex; `NPM_TOKEN` with the NPM plugin)\n\n### Detached Head (Monorepo)\n\nSome plugins might use tools that require you to be on a branch.\nThe default setup for travis leaves you in a "Detached Head" state, meaning the git HEAD pointer is not on a branch.\nTo fix this add the following lines to your `.travis.yml`\n\n```yml\nbefore_deploy:\n  - if [ "$TRAVIS_BRANCH" == "master" ];then\n    git checkout master;\n    fi;\n```\n\nThis code will ensure that your git HEAD is on master when creating a new release.\n\n### Canary Deploy Failing on Forks\n\nBy default Travis will not pass secrets to forks.\nBecause of this canaries releases will fail.\nYou can either:\n\n- Pass secrets to forks (insecure)\n- Only run shipit if secrets are available (recommended, in above config)\n\n## Examples\n\n- [`relay-compiler-language-typescript`](https://github.com/relay-tools/relay-compiler-language-typescript/blob/master/.travis.yml)\n'},{id:"home.md",body:"\x3c!-- no-hero --\x3e\n\n::: home\n:::\n"},{id:"blog/both-worlds.md",body:'---\nimage: https://images.unsplash.com/photo-1554916171-0cfab61e5607?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1200&h=600&fit=crop&ixid=eyJhcHBfaWQiOjF9\ntitle: Best of Both Worlds\nauthor:\n  name: Andrew Lisowski\n  url: https://twitter.com/HipsterSmoothie\n  email: lisowski54@gmail.com\n---\n\nOne of the main goals we had when building auto was to ease the introduction to automated releases through using pull request labels.\n\nThe main alternative to auto works in a slightly different way, [semantic-release](https://github.com/semantic-release/semantic-release) uses the [conventional commit spec](https://www.conventionalcommits.org/en/v1.0.0-beta.4/) to calculate the next version. This is an awesome way to accomplish automated releases, but it is very strict and can create more work when accepting outside contribution. PR labels solve this problem beautifully, but...\n\n![Why not both](https://i.giphy.com/media/cjYH0IhoWiQk8/giphy.webp) /.mediumImage\\\n\nThat\'s exactly why we made the [conventional-commits plugin](). It allows you to keep your conventional commit work flow but still get the benefits of PR labels based automation.\n\nTo start using conventional commit style commit messages simply add the following to your auto config.\n\n```json\n{\n  "plugins": ["conventional-commits"]\n}\n```\n\nNow you can enjoy the best of both worlds! :tada:\n'},{id:"blog/npm-canary-scope.md",body:'---\nimage: https://images.unsplash.com/photo-1566386087068-55645996b234?crop=entropy&cs=tinysrgb&fit=crop&fm=jpg&h=500&ixid=eyJhcHBfaWQiOjF9&ixlib=rb-1.2.1&q=80&w=1950\ntitle: \'npm: More Secure Canary Publishing\'\nauthor:\n  name: Andrew Lisowski\n  url: https://twitter.com/HipsterSmoothie\n  email: lisowski54@gmail.com\n---\n\nPublishing canary versions comes with some security risks.\nIf your project is private you have nothing to worry about, but if your project is open source there are some security holes.\n\n## Attack Vectors\n\nDepending on the build platform you might be able to pass secrets to PR builds for forked repos.\nWhile this makes the developer experience of your project nice, in `auto`\'s case publishing canary versions, it exposes your keys.\n\nAn attacker could:\n\n1. print secrets\n2. send secrets to some server\n3. modify `auto` to publish to the latest tag instead of `canary`\n\nNo amount of code can fix these problems.\nIf your release keys are in everyone\'s CI builds an attacker can do any number of things to modify what you intend for `auto` to do (or any other release method run in the CI).\n\n## Solution\n\nThe solution for this is actually quite simple:\n\n1. Create a test scope that you publish canaries under (ex: `@auto-canary` or `@auto-test`)\n2. Create a user that only has access to that scope\n3. Set the default `NPM_TOKEN` to a token that can publish to that scope (this is used for any pull request)\n4. Set up a `secure` token that is only accessible on the main fork (still named `NPM_TOKEN`)\n\nStep 3 might not be possible on your build platform.\n\nThe following are the ways the `auto` team knows how to do it.\nIf you do not see the method for you build platform, please make a pull request!\n\n- [CircleCI Context](https://circleci.com/docs/2.0/contexts/) - Contexts provide a mechanism for securing and sharing environment variables across projects. The environment variables are defined as name/value pairs and are injected at runtime.\n\n## Usage\n\nTo use this work flow in `auto`, supply the following configuration to the `npm` plugin.\n\n```json\n{\n  "plugins": [\n    [\n      "npm",\n      {\n        "canaryScope": "@auto-canary"\n      }\n    ]\n  ]\n}\n```\n\nNow when people make pull requests to your repos:\n\n1. your CI can run `auto shipit`\n2. the canary versions will get published under your `canaryScope`\n'},{id:"blog/pr-in-progress.md",body:"---\nimage: https://images.unsplash.com/photo-1554520735-0a6b8b6ce8b7?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1200&h=600&fit=crop&ixid=eyJhcHBfaWQiOjF9\ntitle: Merging PRs to other PRs\nauthor:\n  name: Andrew Lisowski\n  url: https://twitter.com/HipsterSmoothie\n  email: lisowski54@gmail.com\n---\n\nSometimes you are working on a big feature and you know it will require a lot of changes. These types of pull requests can be a nightmare to review. Taking in all the changes at once can be overwhelming. It makes it easy to miss smaller mistakes and can make it hard to guess the intent of the changes. Multiple features, bug fixes, or even breaking changes may make up this large PR.\n\nOne way to manage this problem is by making a PR to the large PR. Other contributors can review a smaller subset of changes and also follow along with development. In previous versions of `auto`, large PRs would not be represented well in the changelog and release notes. It would only include the main PR that got merged into master as the only changelog note.\n\nBut thanks to [this PR](https://github.com/intuit/auto/pull/359) that isn't true anymore! Now when you merge one PR to another both changes will be represented in the changelog.\n\n![Clapping](https://i.giphy.com/media/l4HodBpDmoMA5p9bG/200w.webp) /.smallImage\\\n\n_Score!_ /.has-text-centered\\\n\n---\n\nFor example in [PR #351](https://github.com/intuit/auto/pull/351) we changed what happens when you call `shipit` from a PR. Previously if you called `shipit` it would create a new release and publish it to the `latest` tag. The PR made it so `shipit` would create a canary release when run in a PR and only publish to latest from the `master` branch.\n\nAnother [contributor](https://github.com/zephraph) to the project pointed out that some users might not be using `master` as their base branch, so the `baseBranch` should be configurable.\n\nInstead of waiting for #351 to get merged to write the `baseBranch` functionality, I could make a PR to #351 and both PRs would be represented in the changelog!\n\n![Sample release notes](../images/pr-to-pr.png)\n\n---\n\nNow you can be a little more creative with how you manage large PR and have even more detailed changelogs.\n"},{id:"blog/using-shipit.md",body:"---\nimage: https://images.unsplash.com/photo-1556473062-062e556b0920?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1950&q=80\ntitle: Stress-free Continuous Delivery with auto\nauthor:\n  name: Andrew Lisowski\n  url: https://twitter.com/HipsterSmoothie\n  email: lisowski54@gmail.com\n---\n\n`auto` makes releasing your code a breeze. Instead of manually calculating a version and doing your whole release process manually, `auto` takes care of it for you.\n\nThe main command most users use to interact with `auto` is the shipit command. shipit does all the heaving lifting when releasing your code.\n\nWhen run on master it will:\n\n1. Determine if the last merged PR needs to be released\n2. Update a CHANGELOG.md with all you new changes\n3. Publish to NPM\n4. Make a release on GitHub and mark it as latest\n\nWhen run from a PR or locally it will create a canary version.\n\n---\n\n## How does itÂ work?\n\n`auto` does all this magic through GitHub labels. This makes managing outside contribution super easy. Contributors code, you determine the appropriate label, and `auto` takes care of the rest.\n\nThere are a few types of labels:\n\n1. Release Labels\n2. Changelog Labels\n3. Arbitrary labels\n\n---\n\n### Release Labels\n\nThese labels will help you release semantically versioned packages. If no label is present `auto` assumes the PR is a patch.\n\n- major: The PR changes the public API in some way. Create a major release\n- minor: The PR adds a feature to the public API. Create a minor release\n- patch: The PR fixes a bug. Create a patch release\n- skip-release: The PR should not be released. This labels can be used in conjunction with the previous labels for when the PR is actually released\n- internal: Changes only effect how the app is structured or something that doesn't effect the user. This counts as a patch release\n\n### Changelog Labels\n\nThese labels can be used to make your changelogs more expressive. Add them to PRs with release labels to override what changelog section the changes display in. Or use them on their own to just create a patch release.\n\nYou can configure more changelog sections, read more here.\n\n### Arbitrary labels\n\n`auto` doesn't use any extra labels, but you can use whatever labels to power more `auto`mated workflows with `auto` label. This command will return the labels for a PR. Using that information you can choose to run extra CI jobs.\n\nFor example,. the following will only run the test:visual script when the PR has has the Visual label.\n\n```sh\nexport PATH=$(npm bin):$PATH\n\nif [ `auto label --pr $PR_NUMBER | grep -c '^Visual'` -ne 0 ];\nthen\n    npm run test:visual\nfi\n```\n\n---\n\n## Wrapping Up\n\nNow that you know all of the above, you have all you need to release every build as the correct version. No longer worry what tag to publish to or what version. You should never really have to run `auto` yourself, the CI will do that on each build!\n\nAll you have to know is what the labels are and when to use them.\n\nIf you have any questions about how to use `auto` feel free to ask! I hope you guys enjoy the automated release process! :gift:\n"},{id:"blog/v8.md",body:'---\nimage: https://images.unsplash.com/photo-1485795046599-702122cd1267?crop=entropy&cs=tinysrgb&fit=crop&fm=jpg&h=500&ixid=eyJhcHBfaWQiOjF9&ixlib=rb-1.2.1&q=80&w=1950\ntitle: Announcing "auto" 8.0.0\nauthor:\n  name: Andrew Lisowski\n  url: https://twitter.com/HipsterSmoothie\n  email: lisowski54@gmail.com\n---\n\nWe are excited to announce the release of `auto` 8.0.0.\nThis release brings a new command `next`, a new use for `shipit`, more powerful label configuration, and more.\n\nIf you are unfamiliar, `auto` is a CLI tool which helps you version your code and automate any part of your release pipeline.\n`auto`\'s main use is for automating your versioning with [semantic versioning](https://semver.org/) and [GitHub](https://github.com/) pull request labels.\nIt handles determining the next version, creating changelogs, publishing to package managers, publishing [GitHub Releases](https://help.github.com/en/github/administering-a-repository/about-releases), and so much more through plugins.\n\nIf you aren\'t already using `auto` you can either install it through npm:\n\n```sh\nnpm install auto\n```\n\nOr if you are publishing to something other than npm:\n\n```sh\n# On OSX\nbrew tap intuit/auto https://github.com/intuit/auto\nbrew install auto\n\n# Or other OSs\n# Download a platform specific version of auto\ncurl -vkL -o - https://github.com/intuit/auto/releases/download/v8.0.0/auto-linux.gz | gunzip > ~/auto\n# Make auto executable\nchmod a+x ~/auto\n```\n\n## `next` Command\n\nThis new command will make a preview release of your code. This entails:\n\n1. Creating a prerelease on package management platform (supported by `npm` and `git-tag` plugins)\n2. Creating a tag and "Pre Release" on GitHub releases page\n\nThe only prerelease branch `auto` comes configured with is `next`.\nYou can configure as many branches as you want with the [prereleaseBranches](/auto/pages/autorc.html#prerelease-branches) `.autorc` option.\nIf your package manager plugin supports release tags, such as the [npm](/auto/plugins/npm/README.html) plugin, `auto` will publish the prerelease branch to a tag of the same name.\nCalling `auto next` from a one of these branches will publish a prerelease, otherwise it will publish to your default prerelease branch/tag.\n\n### Example Usage\n\nGiven the following configuration:\n\n```json\n{\n  "prereleaseBranches": ["beta"]\n}\n```\n\nRun `auto next` from `beta` branch => Publish prerelease to `beta` tag.\nRun `auto next` from `feature` branch => Publish prerelease to `beta` tag.\n\n## Prerelease Branches with `shipit`\n\nThe `shipit` command will now also publish a prerelease when ran from a prerelease branch. You can use this in a few different ways:\n\n1. Two release branches: `master` and `next`\n2. Without `next` Branch (`--only-graduate-with-release-label`)\n3. Multiple `next` Branches (ex: `alpha`, `beta`, `rc`)\n4. Feature Pre-releases\n\nRead more [here](/auto/pages/generated/shipit.html#prereleases).\n\n## Label Configuration\n\nLabel configuration just got a whole lot simpler ðŸŽ‰.\n\n1. Labels can now only be supplied as an array of label objects.\n\n   ```json\n   {\n     "labels": [\n       { "releaseType": "major", "name": "Version: Major" },\n       { "releaseType": "minor", "name": "Version: Minor" },\n       { "releaseType": "patch", "name": "Version: Patch" }\n     ]\n   }\n   ```\n\n2. Instead of using `skipReleaseLabels` just set the label\'s `type` to `skip`\n\n   ```json\n   {\n     "labels": [{ "releaseType": "skip", "name": "NO!" }]\n   }\n   ```\n\n3. Overwrite default labels using `overwrite`\n\n   ```json\n   {\n     "labels": [\n       { "releaseType": "major", "name": "Version: Major", "overwrite": true }\n     ]\n   }\n   ```\n\n4. Add `none` `releaseType`. This will act as a `skip-release` unless paired with a SEMVER label\n\n   ```json\n   {\n     "labels": [{ "releaseType": "none", "name": "documentation" }]\n   }\n   ```\n\n5. Changed `title` to `changelogTitle`.\n\n   ```json\n   {\n     "labels": [{ "changelogTitle": "New Docs Yo!", "name": "documentation" }]\n   }\n   ```\n\n## Upload Assets - Globs\n\nYou might want to upload multiple files or you might not know the file-name (ex: a vscode extension w/ a version number in the name), but you know the pattern of the filenames that you want to upload.\nSo now you can use [globs](https://github.com/mrmlnc/fast-glob#basic-syntax)!\n\n```json\n{\n  "plugins": [["upload-assets", ["./path/**/to/*.file"]]]\n}\n```\n\n## ðŸ’¥ Other Notable Breaking Changes\n\n### Deprecate `--very-verbose, -w` Flag\n\nUsing -w for very verbose logs was a very odd choice on my part (two `v`s next to each other look like a `w` ðŸ˜“).\nInstead you can now just add another `-v` and get the very verbose logs!\n\n```sh\n# old\nauto shipit -w\n\n# new\nauto shipit -vv\n# or\nauto shipit --verbose --verbose\n```\n\n---\n\nWe hope you enjoy the new ways you can release your code!\n\nâ€“ Andrew Lisowski and the `auto` Team\n\n[View the full release notes](https://github.com/intuit/auto/releases/tag/v8.0.0).\n'},{id:"blog/why.md",body:"---\nimage: https://cdn-images-1.medium.com/max/800/1*TVSbt7qsyleNiQ84la_log.jpeg\ntitle: Death to Monotony\nauthor:\n  name: Adam Dierkens\n  url: https://github.intuit.com/adierkens\n---\n\n# How auto can â€œhandle the rest for youâ€\n\nIâ€™ve been a front-end engineer at Intuit in San Diego for the past three years. As one of three members of Intuitâ€™s Player team, we are responsible for delivering a JavaScript framework dedicated to rendering most of a userâ€™s experience in [TurboTax](https://turbotax.intuit.com/). We end up releasing a lot of code, usually React components, quite frequently to our internal node package manager (npm) instance. Itâ€™s not uncommon for us to hit double-digit releases in a single day. This means lots of version bumps, release notes, changelogs, Jira tickets, Slack announcements, and all the other goodies that come with communicating to dependent teams, that their bug is now fixed, or a new feature is ready for them to use. While none of these steps are intrinsically difficult, the time commitment adds up quickly, so we wrote auto: a tool to [auto-generate releases based on semantic version labels](https://github.com/intuit/auto).\n\n---\n\n## The Problem\n\nHistorically, our release process involved a lot of manual labor. Before publishing an update to npm, someone on the team had to gather all of the changes merged since our last release, write up a changelog, and figure out what the next version was going to be. This often involved a lot of back and forth between GitHub and Jira. Once we had all of that, we could create a release, publish it to npm, document it in GitHub, and post an update to our teamâ€™s Slack channel. These 6â€“7 monotonous tasks were needed for each release, which easily took up to 30â€“60 minutes out of our day.\n\nTo distribute the pain, each month we would nominate someone as the release marshal, who inherited the responsibilities of handling all of the release tasks. It was an inefficient, joyless process that we all resented. Something needed to change.\n\n---\n\n## The Solution\n\nAuto started as a simple Node script that made a few requests to the GitHub API. It gathered the commits merged from the last release and posted those to GitHub. We still had some manual steps in the release process, but it was the start of the end of the monotony.\n\nI brought in another engineer on my team, [Andrew Lisowski](https://www.linkedin.com/in/andrew-lisowski-8b419977/), and we spent the next few months building out the script into a proper npm module. We gave it a well-defined API comprised of small atomic operations that could handle all parts of the release. With auto, the new process is entirely hands-offâ€Šâ€”â€Šsimply hit â€œmergeâ€, and everything happens automatically.\n\nWe initially crafted auto to solve for our teamâ€™s specific release processâ€Šâ€”â€Šwhich needed to post comments and statuses back to a pull request, generate release notes based on what was merged, and document these releases on GitHub and Slack. We eliminated the need for a dedicated release marshal, instead opting for each engineer to annotate their pull requests with a proper semantic version label. Auto would then take it from there, deploying and documenting the release without the need for manual intervention. After dogfooding auto internally for about six months, there was a lot of interest from outside teams, and we knew each of them had slightly different release pipelines, so we worked to make it reusable and customizable for anyone that wanted to use it.\n\nAndrew and I had been talking about using TypeScript for a while and decided that this was a perfect project to start out. By bringing static type-checking to our JavaScript code, refactoring became much less painful, as types quickly caught would-be bugs much sooner. Since writing auto, weâ€™ve made it a point to use TypeScript as our de facto language in any new project we create, including many of the front-end components used in TurboTax today.\n\nInspired by the power and modularity of webpackâ€™s plugin architecture, we brought in their tap-able module, the core code that powers their plugins. Andrew and I spent about a month slowly refactoring the code to leverage the plugin-based architecture you see today. It went live on [GitHub](https://github.com/intuit/auto) in December 2018 and has since attracted several outside contributors.\n\nAndrew was also getting more involved in the open source community at Intuit, and auto seemed like a great fit for a project to release nextâ€Šâ€”â€Šany work that weâ€™d need to do to make auto pluggable for teams inside of Intuit also meant that teams outside of Intuit could leverage it.\n\nWhile a few libraries with similar capabilities already exist, we had yet to identify one that truly met our needs. Packages such as semantic-release were a great inspiration to auto-calculate a version bump based on merged changes, but require a significant change to a developerâ€™s workflow, something we werenâ€™t prepared to enforce.\n\nAutoâ€™s philosophy is to compose each part of the release pipeline into a series of plugins, allowing it to handle a bunch of different use-cases out of the box. Ultimately it boils down to two commands: â€œauto initâ€ to get started and â€œauto shipitâ€ to release. Anyone can write a plugin for any part of the release process and add their own custom handlers, without having to change the core system. If instead of publishing to npm, you want to publish an extension to the Chrome Web Store, simply enable that plugin and auto will handle the rest for you.\n\nWe were pleasantly surprised by how quickly auto was picked up by the community. It filled a niche that the existing libraries didnâ€™t quite cover. By using labelsâ€Šâ€”â€Šinstead of specially formatted commit messages required by some existing solutionsâ€Šâ€”â€Šwe were able to significantly lower the barriers to entry for auto. Auto doesnâ€™t impede the developer workflowâ€Šâ€”â€Šjust throw a label on a pull request and continue to focus on code.\n\nWorking on auto from the start has been an amazing experienceâ€Šâ€”â€Šnot only did it help our team, but itâ€™s awesome to see other teams integrating it into their releases. Iâ€™m really happy that we got to share it with the open source community and am excited to see where the future takes it next.\n"},{id:"pages/writing-plugins.md",body:"# Writing Plugins\n\nIf you've ever written a `webpack` plugin it's a lot like that.\n\nA plugin definition is:\n\n- a class the has an `apply` function where a plugin hooks into various functions in auto (REQUIRED)\n- a name for the plugin, should match the [name of the package](/auto/pages/plugins.html#plugin-declaration) (REQUIRED)\n- a constructor where you can load plugin specific config\n\n```ts\nimport { Auto, IPlugin } from 'auto';\n\nexport default class TestPlugin implements IPlugin {\n  name = 'test';\n\n  private readonly config: any;\n\n  constructor(config: any) {\n    this.config = config;\n  }\n\n  apply(auto: Auto) {\n    // hook into auto\n  }\n}\n```\n\nOr in JavaScript:\n\n```js\nmodule.exports = class TestPlugin {\n  constructor(config) {\n    this.config = config;\n    this.name = 'test';\n  }\n\n  /**\n   * Setup the plugin\n   * @param {import('@auto-it/core').default} auto\n   */\n  apply(auto) {\n    // hook into auto\n  }\n};\n```\n\n## Constructor\n\nIn the constructor you have access to any plugin specific config provided in the `.autorc`. It might be useful to write a more type-safe interface for your config.\n\n```ts\nimport { Auto, IPlugin } from 'auto';\n\ninterface ITestPluginConfig {\n  foo?: string;\n  bar?: boolean;\n}\n\nexport default class TestPlugin implements IPlugin {\n  name = 'test';\n\n  private readonly config: ITestPluginConfig;\n\n  constructor(config: ITestPluginConfig) {\n    this.config = config;\n  }\n}\n```\n\n## Hooks\n\nPlugins work by hooking into various actions that `auto` has to do in order to facilitate a release or interact with your GitHub repo. The hooks that it exposes are:\n\n---\n\n### Main Hooks\n\n#### beforeRun\n\nHappens before anything is done. This is a great place to check for platform specific secrets such as a npm token.\n\n```ts\nauto.hooks.beforeRun.tapPromise('NPM', async config => {\n  if (!process.env.NPM_TOKEN) {\n    auto.logger.log.warn('NPM Token is needed for the NPM plugin!');\n  }\n});\n```\n\n#### modifyConfig\n\nModify what is in the config. You must return the config in this hook.\n\n```ts\nauto.hooks.modifyConfig.tap('test', config => {\n  config.labels.released = {\n    name: 'released',\n    description: 'This issue/pull request has been released'\n  };\n\n  return config;\n});\n```\n\n#### validateConfig\n\nValidate how your plugin is configured.\nMake sure to account for the [different ways you plugin can be included](/auto/pages/plugins.html#plugin-declaration) in an `.autorc`.\n\n```ts\nauto.hooks.validateConfig.tapPromise('test', (name, options) => {\n  if (name === this.name || name === `@auto-it/${this.name}`) {\n    return; // your validation error. Can either be strings for { path, expectedType, value }\n  }\n});\n```\n\n`auto` and it's plugins use [io-ts](https://github.com/gcanti/io-ts) to validate the options for a plugin.\nIf you're using typescript this is a great way to define the options for your plugin.\n\n```ts\n// Types in TypeScript\ninterface Options {\n  level?: string;\n  user?: string;\n}\n\n// The equivalent io-ts code\nimport * as t from 'io-ts';\n\nconst pluginOptions = t.partial({\n  level: t.string,\n  user: t.string\n});\n\nexport type Options = t.TypeOf<typeof pluginOptions>;\n```\n\nSince your type information will now be available at runtime (in `pluginOptions`) you can use this to validate the configuration!\nTo do this `auto` exposes a helper function to validate you plugins with the `io-ts` types.\n\n```ts\nimport { validatePluginConfiguration } from '@auto-it/core';\n\nauto.hooks.validateConfig.tapPromise('test', (name, options) => {\n  if (name === this.name || name === `@auto-it/${this.name}`) {\n    return validatePluginConfiguration(this.name, pluginOptions, options);\n  }\n});\n```\n\n#### beforeShipIt\n\nHappens before `shipit` is run. This is a great way to throw an error if a token or key is not present.\n\nContext Object:\n\n- `releaseType` (`latest` | `old` | `next` | `canary`) - The type of release `shipit` will attempt to make.\n\n```ts\nauto.hooks.beforeRun.tapPromise('NPM', async context => {\n  if (!process.env.NPM_TOKEN) {\n    throw new Error('NPM Token is needed for the NPM plugin!');\n  }\n});\n```\n\n#### beforeCommitChangelog\n\nRan before the `changelog` command commits the new release notes to `CHANGELOG.md`.\nUseful for modifying the changelog as a whole or creating extra `changelog` files. These files can be apart of the commit that updates the changelog.\n\n- bump - the semver bump\n- commits - the commits in the changelog\n- currentVersion - version that was just released\n- lastRelease - the version before the current version\n- releaseNotes - generated release notes for the release\n\n```ts\nauto.hooks.beforeCommitChangelog.tap(\n  'MyPlugin',\n  async ({ currentVersion, commits, releaseNotes, lastRelease }) => {\n    // do something\n  }\n);\n```\n\n#### afterAddToChangelog\n\nRan after the `changelog` command adds the new release notes to `CHANGELOG.md`.\nUseful for getting extra commits into a release before publishing.\n\n- bump - the semver bump\n- commits - the commits in the changelog\n- currentVersion - version that was just released\n- lastRelease - the version before the current version\n- releaseNotes - generated release notes for the release\n\n```ts\nauto.hooks.afterAddToChangelog.tap(\n  'MyPlugin',\n  async ({ currentVersion, commits, releaseNotes, lastRelease }) => {\n    // do something\n  }\n);\n```\n\n#### afterRelease\n\nRan after the `release` command has run. This async hook gets the following arguments:\n\n- `lastVersion` - the version that existed prior to the current release\n- `nextVersion` - version that was just released\n- `commits` - the commits in the release\n- `releaseNotes` - generated release notes for the release\n- `response` - the response returned from making the release\n\n```ts\nauto.hooks.afterRelease.tapPromise(\n  'MyPlugin',\n  async ({ lastVersion, nextVersion, commits, releaseNotes, response }) => {\n    // do something\n  }\n);\n```\n\n#### makeRelease\n\nRan when trying to make a release during the `release` command has run. This async hook gets the following arguments:\n\n- `dryRun` - Whether this is a dry run\n- `from` - Commit to start calculating the version from\n- `newVersion` - The version being released\n- `isPrerelease` - Whether the release being made is a prerelease\n- `fullReleaseNotes` - The generated release notes for all of the commits\n- `commits` - The commits included in the release\n\n```ts\nauto.hooks.makeRelease.tapPromise('MyPlugin', async options => {\n  if (!options.dryRun) {\n    this.logger.log.info(`Releasing ${options.newVersion} to GitHub.`);\n\n    return this.git!.publish(\n      options.fullReleaseNotes,\n      options.newVersion,\n      options.isPrerelease\n    );\n  }\n});\n```\n\n#### afterShipIt\n\nRan after the `shipit` command has run.\n\n- `newVersion` - The new version that was release\n- `commits` - the commits in the release\n- `data`\n  - `context` - The type of release that was created (`latest`, `next`, `canary`, or `old`)\n\n```ts\nauto.hooks.afterShipIt.tap(\n  'MyPlugin',\n  async (newVersion, commits, { context }) => {\n    // do something\n  }\n);\n```\n\n#### getAuthor\n\nGet git author. Typically from a package distribution description file.\n\n```ts\nauto.hooks.getAuthor.tapPromise('NPM', async () => {\n  const { author } = JSON.parse(await readFile('package.json', 'utf-8'));\n\n  if (author) {\n    return author;\n  }\n});\n```\n\n#### getPreviousVersion\n\nGet the previous version. Typically from a package distribution description file.\n\n```ts\nauto.hooks.getPreviousVersion.tapPromise('NPM', async () => {\n  const { version } = JSON.parse(await readFile('package.json', 'utf-8'));\n\n  if (version) {\n    return auto.prefixRelease(\n      JSON.parse(await readFile('package.json', 'utf-8')).version\n    );\n  }\n});\n```\n\n#### getRepository\n\nGet owner and repository. Typically from a package distribution description file.\n\n```ts\nauto.hooks.getRepository.tapPromise('NPM', async () => {\n  const owner = // get the owner from package.json\n  const repo = // get the repo from package.json\n\n  return {\n    owner,\n    repo\n  }\n});\n```\n\n#### onCreateRelease\n\nTap into the things the Release class makes. This isn't the same as `auto release`, but the main class that does most of the work.\n\nAvailable hooks:\n\n- onCreateLogParse (detailed [below]())\n- onCreateChangelog (detailed [below]())\n\n```ts\nthis.hooks.onCreateRelease.tap('MyPlugin', release => {\n  release.hooks.onCreateLogParse.tap('Change log parseing', logParse =>\n    // extend logParse\n  );\n\n  release.hooks.onCreateChangelog.tap(\n    'Change changelog',\n    changelog => {\n      // extend changelog\n    }\n  );\n});\n```\n\n#### onCreateChangelog\n\nThis is where you hook into the changelog's hooks. See usage [below](#changelog-hooks). This hook is exposed for convenience on during `this.hooks.onCreateRelease` and at the root `this.hooks`\n\n#### onCreateLogParse\n\nThis is where you hook into the LogParse's hooks. See usage [below](#logparse-hooks). This hook is exposed for convenience on during `this.hooks.onCreateRelease` and at the root `this.hooks`\n\n#### version\n\nVersion the package. This is a good opportunity to `git tag` the release also. Here `npm` does it for us.\n\n```ts\nauto.hooks.version.tapPromise('NPM', async (version: SEMVER) => {\n  await execPromise('npm', [\n    'version',\n    version,\n    '-m',\n    'Bump version to: %s [skip ci]'\n  ]);\n});\n```\n\n#### afterVersion\n\nRan after the package has been versioned.\n\n#### publish\n\nPublish the package to some package distributor. You must push the tags to github!\n\n```ts\nauto.hooks.publish.tapPromise('NPM', async (version: SEMVER) => {\n  await execPromise('npm', [\n    'version',\n    version,\n    '-m',\n    'Bump version to: %s [skip ci]'\n  ]);\n  await execPromise('npm', ['publish']);\n  await execPromise('git', [\n    'push',\n    '--follow-tags',\n    '--set-upstream',\n    auto.remote,\n    '$branch'\n  ]);\n});\n```\n\n#### afterPublish\n\nRan after the package has been published.\n\n---\n\n#### canary\n\nUsed to publish a canary release. In this hook you get the semver bump and the unique canary postfix ID.\n\nYou can either return a string value of just the version or an object containing the following which will be rendered within and HTML details element.\n\n- `newVersion` - The version published in the canary release or a header for the details element.\n- `details` - The body of the details element\n\n```ts\nauto.hooks.canary.tapPromise(this.name, async (version, postFix) => {\n  const lastRelease = await auto.git!.getLatestRelease();\n  const current = await auto.getCurrentVersion(lastRelease);\n  const nextVersion = inc(current, version as ReleaseType);\n  const isScopedPackage = name.match(/@\\S+\\/\\S+/);\n  const canaryVersion = `${nextVersion}-canary${postFix}`;\n\n  await execPromise('npm', ['version', canaryVersion, '--no-git-tag-version']);\n  await execPromise('npm', ['publish', '--tag', 'canary']);\n\n  auto.logger.verbose.info('Successfully published canary version');\n  return canaryVersion;\n});\n```\n\n### Changelog Hooks\n\n#### addToBody\n\nAdd extra content to your changelogs.\nThis hook provide all the current \"extra\" notes and all of the commits for the changelog.\nYou must return the notes array.\n\nThe following adds a random GIF from [giphy](https://giphy.com) to each new changelog.\n\n```ts\nauto.hooks.onCreateChangelog.tapPromise('Giphy', changelog =>\n  changelog.hooks.renderChangelogLine.tapPromise(\n    'Giphy',\n    async (notes, commits) => {\n      const response = await fetch(`https://api.giphy.com/v1/gifs/random?api_key=${process.env.GIPHY_KEY}`);\n      const json = await response.json();\n      const { data: gif } = json;\n\n      return [...notes, `![${gif.title}](${gif.url})\\n`]\n    }\n  );\n);\n```\n\n#### renderChangelogLine\n\nChange how the changelog renders lines. This hook provides the commit and the current state of the line render. You must return the commit and the line string state as a tuple ([commit, line]).\n\nThe following plugin would change all the bullet points in the changelog to star emojis.\n\n```ts\nauto.hooks.onCreateChangelog.tapPromise('Stars', changelog =>\n  changelog.hooks.renderChangelogLine.tapPromise(\n    'Stars',\n    async (commit, line) =>\n      [commit, `${line.replace('-', ':star:')}\\n`]\n  );\n);\n```\n\n#### renderChangelogTitle\n\nChange how the changelog renders titles. The hook provides the current label for the section and all the configured changelog titles.\n\n```ts\nauto.hooks.onCreateChangelog.tapPromise('Stars', changelog =>\n  changelog.hooks.renderChangelogTitle.tap(\n    'My Titles',\n    (label, changelogTitles) => `:heart: ${changelogTitles[label]} :heart:`\n  );\n);\n```\n\n#### renderChangelogAuthor\n\nChange how the changelog renders authors. This is both the author on each commit note and the user in the author section (the part between parentheses). This is generally a link to some profile.\n\n```ts\nauto.hooks.onCreateChangelog.tapPromise('Stars', changelog =>\n  changelog.hooks.renderChangelogAuthor.tap(\n    'test',\n    (author, commit) => `:heart: ${author.name}/${commit.authorEmail} :heart:`\n  );\n);\n```\n\n#### renderChangelogAuthorLine\n\nChange how the changelog renders authors in the authors section. The hook provides the author object and the user created with `renderChangelogAuthor`. Here is where you might display extra info about the author, such as their full name.\n\n```ts\nauto.hooks.onCreateChangelog.tapPromise('Stars', changelog =>\n  changelog.hooks.renderChangelogAuthorLine.tap(\n    'test',\n    (author, user) => `:shipit: ${author.name} (${user})\\n`\n  );\n);\n```\n\n#### createChangelogTitle\n\nControl the titles in the `CHANGELOG.md`\n\n```ts\n// Render only the date in the title\nauto.hooks.onCreateRelease.tap(this.name, release => {\n  release.hooks.createChangelogTitle.tap(\n    `${this.name} - lerna independent`,\n    () => ''\n  );\n});\n```\n\n---\n\n#### omitReleaseNotes\n\nControl what commits effect the additional release notes section.\n\n```ts\nauto.hooks.onCreateChangelog.tap(this.name, changelog => {\n  changelog.hooks.omitReleaseNotes.tap(this.name, commit =>\n    commit.subject.includes('WIP')\n  );\n});\n```\n\n---\n\n### LogParse Hooks\n\n#### parseCommit\n\nParse information about a commit from a commit. Here is where `auto` gets the PR number from the merge commits.\n\n```ts\nauto.hooks.onCreateLogParse.tapPromise('Stars', logParse =>\n  logParse.hooks.parseCommit.tap(\n    'test',\n    (commit) => {\n      const bump = getBump(commit.subject, logParse.options.versionLabels);\n      commit.labels = [bump]\n      return commit;\n    }\n  );\n);\n```\n\n#### omitCommit\n\nChoose to omit certain commits. If you return true the commit will be omitted. Be sure to return nothing if you don't want the commit omitted.\n\n```ts\nauto.hooks.onCreateLogParse.tapPromise('Stars', changelog =>\n  changelog.hooks.omitCommit.tap(\n    'test',\n    (commit) => {\n      if (someTest(commit.subject)) {\n        return true;\n      }\n    }\n  );\n);\n```\n\n### Init Hooks\n\n#### writeRcFile\n\nOverride where/how the rc file is written.\n\n```ts\nclass MyPlugin implements IPlugin {\n  init(initializer: InteractiveInit) {\n    initializer.hooks.writeRcFile.tapPromise('Example', async rc => {\n      // write the file somewhere other than .autorc\n      return filename;\n    });\n  }\n}\n```\n\n#### getRepo\n\nGet or verify the repo information.\n\n#### getAuthor - init\n\nGet or verify the author information.\n\n#### configurePlugin\n\nRun extra configuration for a plugin. Here is where to display prompts to the user.\n\n```ts\nclass MyPlugin implements IPlugin {\n  init(initializer: InteractiveInit) {\n    initializer.hooks.configurePlugin.tapPromise('Example', async name => {\n      if (name === 'my-plugins') {\n        return [\n          name,\n          {\n            // extra config options\n          }\n        ];\n      }\n    });\n  }\n}\n```\n\n#### createEnv\n\nAdd environment variables to get from the user\n\n```ts\nclass MyPlugin implements IPlugin {\n  init(initializer: InteractiveInit) {\n    initializer.hooks.createEnv.tap('Example', vars => [\n      ...vars,\n      {\n        variable: 'MY_TOKEN',\n        message: `This is a very important secret`\n      }\n    ]);\n  }\n}\n```\n\n## Example Plugin - NPM (simple)\n\nTo create a plugin simply make a class with an `apply` method and tap into the hooks you need.\n\n```ts\nimport * as fs from 'fs';\nimport { promisify } from 'util';\n\nimport { IAutoHooks, Auto, SEMVER, execPromise } from 'auto';\nimport getConfigFromPackageJson from './package-config';\n\nconst readFile = promisify(fs.readFile);\n\nexport default class NPMPlugin {\n  public apply(auto: Auto) {\n    auto.hooks.getAuthor.tapPromise('NPM', async () => {\n      const { author } = JSON.parse(await readFile('package.json', 'utf-8'));\n\n      if (author) {\n        auto.logger.log.info('NPM: Got author information from package.json');\n        return author;\n      }\n    });\n\n    auto.hooks.getPreviousVersion.tapPromise('NPM', async () => {\n      const { version } = JSON.parse(await readFile('package.json', 'utf-8'));\n\n      auto.logger.log.info(\n        'NPM: Got previous version from package.json - ',\n        version\n      );\n\n      if (version) {\n        return auto.prefixRelease(\n          JSON.parse(await readFile('package.json', 'utf-8')).version\n        );\n      }\n    });\n\n    auto.hooks.getRepository.tapPromise('NPM', async () => {\n      auto.logger.log.info('NPM: getting repo information from package.json');\n      return getConfigFromPackageJson();\n    });\n\n    auto.hooks.publish.tapPromise('NPM', async (version: SEMVER) => {\n      await execPromise('npm', [\n        'version',\n        version,\n        '-m',\n        'Bump version to: %s [skip ci]'\n      ]);\n      await execPromise('npm', ['publish']);\n      await execPromise('git', [\n        'push',\n        '--follow-tags',\n        '--set-upstream',\n        auto.remote,\n        '$branch'\n      ]);\n    });\n  }\n}\n```\n"},{id:"pages/extras/changelog.md",body:"::: message is-warning\n:warning: This should be run before you version your project so the `CHANGELOG.md` changes are committed before the release gets tagged.\n:::\n\n## Changelog Titles\n\nYou can customize the changelog titles and even add custom ones. To see configuration [go here](/auto/pages/autorc.html#changelog-titles).\n\n## Additional Release notes\n\nSometimes a PR title is just not enough to capture what a user should know about that PR. That's why we've included the ability to put extra release notes right in your PRs. All you have to do is add a `Release Notes` section in your PR.\n\nTake the following PR body:\n\n```md\n# What Changed\n\nChange `shipit` behavior.\n\n## Release Notes\n\n`auto shipit` will only ship to `latest` on the base branch ([which is configurable]()). If ran locally or from a PR it will create a `canary` release that doesn't interfere with your `latest` release.\n```\n\nThis will create a special section at the top of the changelog that collects all the additional release notes from merged PRs. Below is a sample of what it might look like.\n\n---\n\n# v5.0.0 (Sat May 04 2019)\n\n### Release Notes\n\n_From #371_\n\n`auto shipit` will only ship to `latest` on the base branch ([which is configurable]()). If ran locally or from a PR it will create a `canary` release that doesn't interfere with your `latest` release.\n\n---\n\n#### ðŸ’¥ Breaking Change\n\n- shipit will publish a canary locally when not on master [#371](https://github.com/intuit/auto/pull/371) ([@hipstersmoothie](https://github.com/hipstersmoothie))\n\n#### Authors: 1\n\n- Andrew Lisowski ([@hipstersmoothie](https://github.com/hipstersmoothie))\n"},{id:"pages/autorc.md",body:'# `auto` RC File\n\n`auto` uses [cosmiconfig](https://github.com/davidtheclark/cosmiconfig) to find your config. This means you can define this file a variety of ways. Our `cosmiconfig` setup is custom and will start at the root of your project and start to search up the directory tree for the following:\n\n- a JSON or YAML, extension-less "rc file"\n- an "rc file" with the extensions `.json`, `.yaml`, or `.yml`\n- a package.json property\n\n`auto` does not support writing configuration files in JavaScript.\n\n## Initialization\n\nTo interactively create an `.autorc` use the `init` command. You can configure most flags and all labels/changelogTitles.\n\n```sh\nauto init\n```\n\n## Options\n\nThe following are all of the top level configuration options for `auto`.\nWhile some of the following options also exist as flags to certain comments,\nit is recommended to set them in an `.autorc` so your commands are terser and experience consistent.\n\n### Only Publish With Release Label\n\nConfigure the default release behavior.\n\n```js\n{\n  "onlyPublishWithReleaseLabel": true\n}\n```\n\n### Base Branch\n\nConfigure what your repo considers the "master" branch.\n\n```js\n{\n  "baseBranch": "trunk"\n}\n```\n\n### Plugins\n\nIt is useful to specify your plugins in the rc file rather than in all the commands.\n\n```js\n{\n  "plugins": ["npm", "../path/to/plugin.js", "NPM_PACKAGE_NAME"]\n}\n```\n\n### githubApi\n\nIf you are using enterprise github, `auto` lets you configure the github API URL that it uses.\n\n```js\n{\n  "githubApi": "https://github.mine.com/api/v3"\n}\n```\n\n### githubGraphqlApi\n\nThis is used for doing some searches in `auto`.\n\nIf you are using enterprise github and your company hosts the graphql at some other URL than the `githubApi`, you can use `githubGraphqlApi` to set the base path for `auto`. The `githubGraphqlApi` get merged with `/graphql` to build the final URL.\n\n```js\n{\n  "githubGraphqlApi": "https://github.mine.com/api/"\n}\n```\n\n### name\n\nName to use with git.\n\n```js\n{\n  "name": "Joe Schmo"\n}\n```\n\n### email\n\nEmail to use with git.\n\n```js\n{\n  "email": "joe@schmo.com"\n}\n```\n\n### Command Defaults\n\nFor some commands you can supply defaults for some options.\n\n**Example:** Adding the following to you `.autorc` will make `auto` only release pre-releases to GitHub.\n\n```json\n{\n  "release": {\n    "prerelease": true\n  }\n}\n```\n\nPlease refer to each command\'s documentation to see which options are configurable.\n\n---\n\n### Exclusive Options\n\nThe following options can be set exclusively in the `.autorc` and do not exist as CLI flags.\n\n### versionBranches\n\nCreate and manage old major releases.\n\n```js\n{\n  "versionBranches": true,\n  // or customize the branch prefix\n  "versionBranches": "major-"\n}\n```\n\n### Prerelease Branches\n\nYou can configure what branches `auto` treats as prerelease branches.\nBy default only `next` is treated as a prerelease branch.\nIf you configure `prereleaseBranches` it will override the default.\n\n```js\n{\n  "prereleaseBranches": ["next", "beta"]\n}\n```\n\n### Labels\n\nTo customize your project\'s labels use the `labels` section in your `.autorc`.\n\n```js\n{\n  "labels": [\n    { "releaseType": "major", "name": "Version: Major" },\n    { "releaseType": "minor", "name": "Version: Minor" },\n    { "releaseType": "patch", "name": "Version: Patch" },\n    { "releaseType": "skip", "name": "NO!" },\n    { "releaseType": "release", "name": "Autobots, rollout!" }\n  ]\n}\n```\n\n<details><summary>Click here to see the default label configuration</summary>\n\n```js\n[\n  {\n    name: \'major\',\n    changelogTitle: \'ðŸ’¥ Breaking Change\',\n    description: \'Increment the major version when merged\',\n    releaseType: \'major\'\n  },\n  {\n    name: \'minor\',\n    changelogTitle: \'ðŸš€ Enhancement\',\n    description: \'Increment the minor version when merged\',\n    releaseType: \'minor\'\n  },\n  {\n    name: \'patch\',\n    changelogTitle: \'ðŸ› Bug Fix\',\n    description: \'Increment the patch version when merged\',\n    releaseType: \'patch\'\n  },\n  {\n    name: \'skip-release\',\n    description: \'Preserve the current version when merged\',\n    releaseType: \'skip\'\n  },\n  {\n    name: \'release\',\n    description: \'Create a release when this pr is merged\',\n    releaseType: \'release\'\n  },\n  {\n    name: \'internal\',\n    changelogTitle: \'ðŸ  Internal\',\n    description: \'Changes only affect the internal API\',\n    releaseType: \'none\'\n  },\n  {\n    name: \'documentation\',\n    changelogTitle: \'ðŸ“ Documentation\',\n    description: \'Changes only affect the documentation\',\n    releaseType: \'none\'\n  }\n];\n```\n\n</details>\n\n#### Label Customization\n\nYou can customize everything about a label\n\n- `name` - The label text used for the label. If omitted defaults to the `key` value\n- `releaseType` - The type of release to trigger (major, minor, patch, skip, release, or none)\n- `overwrite` - Overwrite the default label(s) associated with the `releaseType`. (default: `false`)\n- `changelogTitle` - The title to use in the changelog\n- `description` - The description to use when creating the label\n- `color` - The color of the label. Can be specified as a string in any of [these](https://github.com/bgrins/TinyColor#accepted-string-input) ways. If not specified the color is random\n\n```js\n{\n  "labels": [\n    {\n      "name": "Version: Major",\n      "changelogTitle": "The API has changed:",\n      "description": "Add this label to a PR to create a major release",\n      "color": "blue",\n      "releaseType": "major"\n    }\n  ]\n}\n```\n\n#### Release Type: `none`\n\nA label with the `none` release type will not create a release when merged.\nIf paired with a SEMVER label, the release is not skipped.\n\n```js\n{\n  "labels": [\n    {\n      "name": "documentation",\n      "releaseType": "none"\n    }\n  ]\n}\n```\n\n#### Changelog Titles\n\nEach PR included in the release will be assigned to a label section based upon the matching label with the highest `releaseType` that has a `changelogTitle`.\n\n- Priority order of `releaseType` from highest to lowest is: major, minor, patch, and then all others\n- If a PR has multiple labels of the same `releaseType`, then the PR is assigned based upon the label that is assigned first in the config\n\nBy default auto will create sections in the changelog for the following labels:\n\n- `major`\n- `minor`\n- `patch`\n- `internal`\n- `documentation`\n\nFor example:\n\n- Using the default config, if a given PR has the labels `minor` and `internal`, then it will be included in the `minor` label section\n- Using the default config, if a given PR has the labels `documentation` and `internal`, then it will be included in the `internal` label section\n\n##### Updating Default Label Changelog Titles\n\nTo customize the title for the section in the changelog you can\n\n```js\n{\n  "labels": [\n    {\n      "name": "documentation",\n      "changelogTitle": "Docz"\n    }\n  ]\n}\n```\n\n##### Adding Additional Changelog Title Sections\n\nIf you want more sections in your changelog to further detail the change-set you can\nuse the `labels` section to add more. Any label in the label section with a changelogTitle\nwill become a special section in your changelog.\n\nThe following adds a `typescript` label to the project that we can use to denote changes\nrelated to a TypeScript re-write.\n\n```js\n{\n  "labels": [\n    {\n      "name": "typescript",\n      "changelogTitle": "TypeScript Rewrite"\n    }\n  ]\n}\n```\n\n#### Removing Default Label Changelog Title Sections\n\nYou can remove the existing default label sections by adding a custom overwrite label with the same `releaseType`.\n\nThe following removes the default internal and documentation label sections:\n\n```js\n{\n  "labels": [\n    {\n      "name": "Custom Doc Label",\n      "changelogTitle": "Docz",\n      "releaseType": "none",\n      "overwrite": true\n    }\n  ]\n}\n```\n\n## Extending\n\nIf you want to share your auto configuration between projects you can use the `extends` property. This property will load from a module\'s package.json or from a custom path. It\'s expected that the extended configuration be under the `auto` key in the package.json file.\n\nAuto can load `extends` configs in the following ways:\n\n- from a path `./path/to/config` (this file must be in JSON format)\n- from a scoped package `@YOUR_SCOPE/auto-config` (under the `auto` key in the package.json)\n- from a package `auto-config-YOUR_NAME`\n- from a url `https://yourdomain.com/auto-config.json` (must return the content type `application/json`)\n\n```js\n{\n  "extends": "@YOUR_SCOPE"\n}\n```\n\nWill use the package `@YOUR_SCOPE/auto-config`\n\n```js\n{\n  "extends": "joe"\n}\n```\n\nWill use the package `auto-config-joe`\n\n::: message is-warning\nIf extending from a config package make sure it\'s a dependency of your project\n:::\n\nIf you\'re extending from a local file it can be any file in JSON format or a `package.json` file.\n\n```js\n{\n  "extends": "./path/to/config.json"\n}\n```\n\n```js\n{\n  "extends": "./path/to/other/package.json"\n}\n```\n'},{id:"index.md",body:":tada: Welcome\n\n- [Introduction](/auto/pages/introduction.html)\n- [Getting Started](/auto/pages/getting-started.html)\n- [Merging Quickly](/auto/pages/quick-merge.html)\n\n---\n\n:gear: Configuration\n\n- [.autorc](/auto/pages/autorc.html)\n- [Plugins](/auto/pages/plugins.html)\n- [Non-npm Usage](/auto/pages/non-npm.html)\n- [Writing Plugins](/auto/pages/writing-plugins.html)\n- [Troubleshooting](/auto/pages/troubleshooting.html)\n\n---\n\n:hammer: Tool APIs :wrench:\n\n- [Setup](/auto/pages/generated/init.html)\n  - [auto init](/auto/pages/generated/init.html#init)\n  - [auto create-labels](/auto/pages/generated/init.html#create-labels)\n  - [auto info](/auto/pages/generated/info.html)\n- [Publishing](/auto/pages/publishing.html)\n  - [auto version](/auto/pages/generated/version.html)\n  - [auto changelog](/auto/pages/generated/changelog.html)\n  - [auto release](/auto/pages/generated/release.html)\n  - [auto shipit](/auto/pages/generated/shipit.html)\n  - [auto latest](/auto/pages/generated/latest.html)\n  - [auto next](/auto/pages/generated/next.html)\n  - [auto canary](/auto/pages/generated/canary.html)\n- [PR Interaction](/auto/pages/pr-interaction.html)\n  - [auto label](/auto/pages/generated/label.html)\n  - [auto pr-status](/auto/pages/generated/pr-status.html)\n  - [auto pr-check](/auto/pages/generated/pr-check.html)\n  - [auto pr-body](/auto/pages/generated/pr-body.html)\n  - [auto comment](/auto/pages/generated/comment.html)\n\n---\n\nPackage Manager Plugins\n\n- [Homebrew](/auto/plugins/brew/README.html)\n- [Chrome Web Store](/auto/plugins/chrome/README.html)\n- [Crates](/auto/plugins/crates/README.html)\n- [Cocoapod](/auto/plugins/cocoapods/README.html)\n- [Git Tag](/auto/plugins/git-tag/README.html)\n- [Gradle](/auto/plugins/gradle/README.html)\n- [Maven](/auto/plugins/maven/README.html)\n- [NPM](/auto/plugins/npm/README.html)\n\nFunctionality Plugins\n\n- [All Contributors](/auto/plugins/all-contributors/README.html)\n- [Amazon S3](/auto/plugins/s3/README.html)\n- [Conventional Commits](/auto/plugins/conventional-commits/README.html)\n- [Exec](/auto/plugins/exec/README.html)\n- [First Time Contributor](/auto/plugins/first-time-contributor/README.html)\n- [GitHub Pages](/auto/plugins/gh-pages/README.html)\n- [Jira](/auto/plugins/jira/README.html)\n- [Omit Commits](/auto/plugins/omit-commits/README.html)\n- [Omit Release Notes](/auto/plugins/omit-release-notes/README.html)\n- [Released](/auto/plugins/released/README.html)\n- [Slack](/auto/plugins/slack/README.html)\n- [Twitter](/auto/plugins/twitter/README.html)\n- [Upload Assets](/auto/plugins/upload-assets/README.html)\n\n---\n\n:bathtub: Continuous Integration\n\n- [CircleCI](/auto/pages/build-platforms/circleci.html)\n- [Travis CI](/auto/pages/build-platforms/travis.html)\n- [GitHub Actions](/auto/pages/build-platforms/github-actions.html)\n- [Jenkins 2](/auto/pages/build-platforms/jenkins.html)\n"},{id:"pages/build-platforms/circleci.md",body:"# CircleCI\n\nThe following config declares the `release` job and uses it in the `build_and_release` workflow. The `release` job will run at the end of each build and either release:\n\n- a new `latest` version from `master`\n- a `canary` build from a pull request (if your package manager plugin implements them)\n\n```yaml\nversion: 2\n\ndefaults: &defaults\n  working_directory: ~/auto\n  docker:\n    - image: circleci/node:latest-browsers\n\njobs:\n  install: # your install job\n\n  release:\n    <<: *defaults\n    steps:\n      - attach_workspace:\n          at: ~/auto\n      - run:\n          name: Release\n          command: npx auto shipit\n\nworkflows:\n  version: 2\n  build_and_release:\n    jobs:\n      - install\n\n      - release:\n          requires:\n            - install\n```\n\n## Troubleshooting\n\nIf you are having problems make sure you have done the following:\n\n- `GH_TOKEN` is set\n- Any other secrets for plugins are set (Ex; `NPM_TOKEN` with the NPM plugin)\n\n### Problems pushing tags to github\n\nGo to Settings -> Checkout SSH Keys -> `Create and add YOUR_USERNAME user key`. This will create a key with the ability to push to github.\n\n## Examples\n\n- [`auto`](https://github.com/intuit/auto/blob/master/.circleci/config.yml)\n- [`Ignite`](https://github.com/intuit/Ignite/blob/master/.circleci/config.yml)\n- [`reaction`](https://github.com/artsy/reaction/blob/master/.circleci/config.yml)\n"},{id:"pages/build-platforms/github-actions.md",body:"# GitHub Actions\n\nThe following config declares the `release` action that run on all branches. The job will either release:\n\n- a new `latest` version from `master`\n- a `canary` build from a pull request (only on the main fork and if your package manager plugin implements them)\n\n**`.github/workflows/release.yml`**\n\n::: message is-warning\nYou must use some sort of action that implements `skip ci` functionality (as seen below). Otherwise you will get stuck in a release loop!\n:::\n\n```yaml\nname: Release\n\non: [push]\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n    if: \"!contains(github.event.head_commit.message, 'ci skip') && !contains(github.event.head_commit.message, 'skip ci')\"\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Prepare repository\n        run: git fetch --unshallow --tags\n\n      - name: Use Node.js 12.x\n        uses: actions/setup-node@v1\n        with:\n          node-version: 12.x\n\n      - name: Cache node modules\n        uses: actions/cache@v1\n        with:\n          path: node_modules\n          key: yarn-deps-${{ hashFiles('yarn.lock') }}\n          restore-keys: |\n            yarn-deps-${{ hashFiles('yarn.lock') }}\n\n      - name: Create Release\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}\n        run: |\n          yarn install --frozen-lockfile\n          yarn build\n          npx auto shipit\n```\n\n## Troubleshooting\n\nIf you are having problems make sure you have done the following:\n\n- Any required secrets for plugins are set (e.g. `NPM_TOKEN` with the NPM plugin)\n- Update references of `<your-github-user>`, `<project-owner>`, and `<project-repo>` with the appropriate values\n\n### Running With Branch Protection\n\nGitHub actions require a little more setup to use `auto` with branch protection.\n\n```yml\nsteps:\n  - uses: actions/checkout@v2\n    with:\n      # Ensure that git uses your token with write access to the repo\n      token: ${{ secrets.GH_TOKEN }}\n\n  - name: Prepare repository\n    # Fetch full git history and tags\n    run: git fetch --unshallow --tags\n```\n\n## Examples\n\n- [`auto-config-hipstersmoothie`](https://github.com/hipstersmoothie/auto-config-hipstersmoothie/blob/07d128afd96ac6a7b0fe3f04313847c0fc3d84a2/.github/workflows/push.yml)\n- [`create-check`](https://github.com/hipstersmoothie/create-check/blob/master/.github/workflows/push.yml)\n- [`octokit-cli`](https://github.com/hipstersmoothie/octokit-cli/blob/master/.github/workflows/push.yml)\n"},{id:"pages/build-platforms/jenkins.md",body:"# Jenkins 2\n\nThe following config declares the `release` action that run on all branches. The job will either release:\n\n- a new `latest` version from `master`\n- a `canary` build from a pull request (only on the main fork and if your package manager plugin implements them)\n\n**`Jenkinsfile`**\n\n::: message is-warning\nYou must use some sort of step that implements `skip ci` functionality. Otherwise you will get stuck in a release loop!\n:::\n\n```groovy\n\npipeline {\n  environment {\n    NPM_TOKEN = credentials('NPM_TOKEN')\n    GH_USER = credentials('GH_USER')\n    GH_TOKEN = credentials('GH_TOKEN')\n  }\n  stages {\n    stage('Check Skip CI') {\n      steps {\n        script {\n          result = sh (script: \"git log -1 | grep '.*\\\\[skip ci\\\\].*'\", returnStatus: true)\n          if (result == 0) {\n              echo (\"'Skip CI' spotted in git commit. Aborting.\")\n              currentBuild.result = 'ABORTED'\n              error('Exiting job');\n          }\n        }\n      }\n    }\n    stage('Install') {\n      steps {\n        sh 'yarn install --frozen-lockfile'\n      }\n    }\n    stage('Build') {\n      steps {\n          sh 'yarn build'\n      }\n    }\n    stage('Publish') {\n        when { branch 'master' }\n        steps {\n          // Jenkins will leave you in a detatched HEAD state during builds\n          // Make sure to checkout your baseBranch here or the push will fail!\n          // The error will look like the following:\n          // error: src refspec master does not match any\n          sh 'git checkout master'\n          sh 'auto shipit'\n        }\n    }\n    stage('Canary') {\n      when { changeRequest() }\n      steps {\n        sh 'auto canary --pr $CHANGE_ID --build $BUILD_NUMBER'\n      }\n    }\n  }\n}\n```\n\n## Troubleshooting\n\nIf you are having problems make sure you have done the following:\n\n- `GH_TOKEN` is set\n- Any other secrets for plugins are set (Ex; `NPM_TOKEN` with the NPM plugin)\n"},{id:"pages/pr-interaction.md",body:"# Pull Request Interaction\n\n`auto` also includes a variety of PR interaction tools to update PRs from the CI. You can use these tools in various ways to make your PR validation process much more customized.\n\n<br />\n\nTools:\n\n:star: [auto-label](/auto/pages/auto-label.html) - Get the labels for a PR\n\n:star: [auto-pr](/auto/pages/auto-pr.html) - Set a status on a PR\n\n:star: [auto-pr-check](/auto/pages/auto-pr-check.html) - Check for a semver label and set a status\n\n:star: [auto-comment](/auto/pages/auto-comment.html) - Comment on a PR\n"},{id:"pages/generated/comment.md",body:'# `comment`\n\nComment on a pull request with a markdown message. Each comment has a context, and each context only has one comment.\n\n## Options\n\n| Flag | Type | Description |\n| - | - | - |\n| `--pr` | Number | The pull request the command should use. Detects PR number in CI |\n| `--context` | String | A string label to differentiate this status from others |\n| `--edit`, `-e` | Boolean | Edit old comment |\n| `--delete` | Boolean | Delete old comment |\n| `--message`, `-m` | String | Message to post to comment |\n| `--dry-run`, `-d` | Boolean | Report what command will do but do not actually do anything |\n\n## Examples\n\n```sh\nauto comment --delete\n```\n\n```sh\nauto comment --pr 123 --message "# Why you\'re wrong..."\n```\n\n```sh\nauto comment --pr 123 --edit --message "This smells..." --context code-smell\n```\n\n\n## Configurable Options\n\nYou can configure some of the options for the `comment` command in the `.autorc`.\n\n- `edit`\n- `delete`\n\n**Example `.autorc`:**\n\n```json\n{\n  "comment": {\n    "edit": true,\n    "delete": true\n  }\n}\n```'},{id:"pages/extras/next.md",body:"### Setting up Protected Branches\n\nYou should make your pre-release branches protected on GitHub. This will prevent a bunch of unwanted behavior from happening.\n\n1. Go to you project's setting on [GitHub](https://github.com)\n2. Click `Branches`\n3. Click `Add Rule`\n4. Enter the name of your prerelease branch (ex: `next`)\n5. Configure extra branch protection settings\n6. (Optional) Set the base branch in GitHub to your prerelease branch (this ensure new PRs go to this branch)\n"},{id:"pages/extras/release.md",body:'::: message is-warning\nMake sure you give the `GH_TOKEN` `repo` permission or `release` will fail!\n:::\n\n## Usage\n\n```json\n{\n  "scripts": {\n    "postpublish": "auto release"\n  }\n}\n```\n\nMake sure the branch/tag you\'re releasing is on github before running `auto release`.\nYou will need to push the tags to github first:\n\n```json\n{\n  "scripts": {\n    "postpublish": "git push --follow-tags --set-upstream origin $branch && auto release"\n  }\n}\n```\n\n## Github Release Details\n\nThe details / description published with the Github release will be identical to those generated by the `auto changelog` command.\nSee information regarding the release note format [here](/auto/pages/extras/changelog.html#changelog-titles).\n'},{id:"pages/extras/shipit.md",body:'## Release Pipeline\n\nBelow is the basics steps auto takes when releasing your code through the `shipit` command.\n\n![The default shipit workflow](../../images/default-auto.png)\n\nYou can customize how this pipeline operates with various flags.\nThe following shows how those flags can effect the workflow.\n\n![The entire shipit workflow](../../images/complete-auto.png)\n\n## Managing Old Major Versions\n\nThis command also has the ability to help you manage old major versions too!\nThis feature is off by default, to enable set `versionBranches` to `true` in your [.autorc](/auto/pages/autorc.html#versionbranches).\n\nWith this feature enabled `auto shipit` will:\n\n- Create a version branch when a `major` happens (prefixed with `version-`)\n- When ran from a `versionBranch` make a release to that version\n\nNow that you have a branch for an old major release, it is super easy to release patches to it!\nPeople can make PRs to the the `version-` branch and once merged create a new release of that version.\n\n### Customize Branch Prefix\n\nYou can customize what the branch names will be by setting `versionBranches` to a string.\n\n```json\n{\n  "versionBranches": "Major-"\n}\n```\n\n## Prereleases\n\nIf you are interested in pre-releases (ex: `alpha`, `beta`, `next`) `auto` has the ability to publish pre-releases in various ways.\n\nRead more about preparing you project for pre-releases [here](/auto/pages/generated/next.html#setting-up-protected-branches).\n\n### Strategies\n\n#### "next" Branch (default)\n\nThe suggested way to create pre-releases is by managing 2 branches for your repo: `master` and `next`.\n`master` contains the `latest` stable version of the code, and `next` contains future updates.\n\nYou can change what branches `auto` treats as pre-release branches in your [`.autorc`](/auto/pages/autorc.html#prerelease-branches).\n\n![Example git tree](../../images/next-branch.png)\n\nTo update the `latest` stable version simply merge your pre-release branch into your `baseBranch`.\n\n#### Without "next" Branch (`--only-graduate-with-release-label`)\n\nIf you use the `--only-graduate-with-release-label` flag, you do not have to manage 2 branches.\nInstead you only have a `baseBranch` and do all work and pull requests there.\n`auto` will only publish pre-releases when PRs are merged.\nTo update the `latest` stable version add the `released` label to the PR.\n\nWhile this setup may be simpler, it restricts you from updating latest while development is happening for the pre-release.\nWith 2 branches you can easily merge update to the latest release, with 1 this is not possible.\n\n#### Multiple "next" Branches\n\nSometimes you might want to have more rigorous release lines.\nThis can help test out bugs on a smaller set of users.\n\nOne setup you could use to accomplish this is by creating 3 `prereleaseBranches`\n\n```json\n{\n  "prereleaseBranches": ["alpha", "beta", "rc"]\n}\n```\n\nYou could then set you default to `alpha` and `auto` would publish updates merged to that branch under the `alpha` release tag.\nWhen you are ready for the update to get used by more users just merge `alpha` into `beta`.\nThis will publish a `beta` release to the matching release tag.\nRepeat this same process when graduating to `rc` or `latest`.\n\n#### Feature Pre-releases\n\nSometimes you are working on a large feature that requires a lot of work.\nInstead of making a giant PR with a bunch of updates, you can create a `prereleaseBranch` to track the work.\n\n```json\n{\n  "prereleaseBranches": ["next", "my-cool-feature"]\n}\n```\n\nNow instead of just getting a canary version when merging into the `my-cool-feature` branch, a prerelease version is published under the `my-cool-feature` release tag!\nThis enables other to consume just this line of work and enables your work to be more flexible.\n'},{id:"pages/extras/label.md",body:"## Using in scripts\n\nThe following will only run the test:visual script when the PR has has the  \n Visual label.\n\n```sh\nexport PATH=$(npm bin):$PATH\n\nif [ auto label --pr $PR_NUMBER | grep -c '^Visual' -ne 0 ];\nthen\n  npm run test:visual\nfi\n```\n\n## Without PR Number\n\nRunning `auto label` without the PR number will:\n\n- When run in master will get the labels for the last merged PR\n- When run for a PR in CI will use the PR's number\n"},{id:"pages/extras/version.md",body:"Useful in conjunction with `npm version` to auto-version releases.\n\n## Configure Versioning Labels\n\nYou can customize the versioning labels in the `.autorc`. To see configuration [go here](/auto/pages/extras/autorc.html#versioning-labels).\n"},{id:"pages/generated/canary.md",body:'# `canary`\n\nMake a canary release of the project. Useful on PRs. If ran locally, `canary` will release a canary version for your current git HEAD. This is ran automatically from "shipit".\n\n1. In PR: 1.2.3-canary.123.0 + add version to PR body\n2. Locally: 1.2.3-canary.1810cfd\n\n## Options\n\n| Flag | Type | Description |\n| - | - | - |\n| `--dry-run`, `-d` | Boolean | Report what command will do but do not actually do anything |\n| `--pr` | Number | PR number to use to create the canary version. Detected in CI env |\n| `--build` | String | Build number to use to create the canary version. Detected in CI env |\n| `--message`, `-m` | String | Message to comment on PR with. Defaults to \'Published PR with canary version: %v\'. Pass false to disable the comment |\n| `--force` | Boolean | Force a canary release, even if the PR is marked to skip the release |\n| `--quiet`, `-q` | Boolean | Print **only** the result of the command |\n\n## Examples\n\n```sh\nauto canary\n```\n\n```sh\nauto canary --force\n```\n\n```sh\nauto canary --pr 123 --build 5\n```\n\n```sh\nauto canary --message "Install PR version: `yarn add -D my-project@%v`"\n```\n\n```sh\nauto canary --message false\n```\n\n\n## Configurable Options\n\nYou can configure some of the options for the `canary` command in the `.autorc`.\n\n- `message`\n- `force`\n\n**Example `.autorc`:**\n\n```json\n{\n  "canary": {\n    "message": "string",\n    "force": true\n  }\n}\n```'},{id:"pages/generated/changelog.md",body:"# `changelog`\n\nPrepend release notes to `CHANGELOG.md`, create one if it doesn't exist, and commit the changes.\n\n## Options\n\n| Flag | Type | Description |\n| - | - | - |\n| `--dry-run`, `-d` | Boolean | Report what command will do but do not actually do anything |\n| `--no-version-prefix` | Boolean | Use the version as the tag without the 'v' prefix. WARNING: some plugins might need extra config to use this option (ex: npm) |\n| `--name` | String | Git name to commit  with. Defaults to package definition for the platform |\n| `--email` | String | Git email to commit with. Defaults to package definition for the platform |\n| `--from` | String | Tag to start changelog generation on. Defaults to latest tag. |\n| `--to` | String | Tag to end changelog generation on. Defaults to HEAD. |\n| `--title` | String | Override the title used in the addition to the CHANGELOG.md. |\n| `--message`, `-m` | String | Message to commit the changelog with. Defaults to 'Update CHANGELOG.md [skip ci]' |\n| `--base-branch` | String | Branch to treat as the \"master\" branch |\n| `--quiet`, `-q` | Boolean | Print **only** the result of the command |\n\n## Examples\n\nGenerate a changelog from the last release to head\n\n ```sh\nauto changelog\n```\n\nGenerate a changelog across specific versions\n\n ```sh\nauto changelog --from v0.20.1 --to v0.21.0\n```\n\n\n## Configurable Options\n\nYou can configure some of the options for the `changelog` command in the `.autorc`.\n\n- `message`\n\n**Example `.autorc`:**\n\n```json\n{\n  \"changelog\": {\n    \"message\": \"string\"\n  }\n}\n```\n::: message is-warning\n:warning: This should be run before you version your project so the `CHANGELOG.md` changes are committed before the release gets tagged.\n:::\n\n## Changelog Titles\n\nYou can customize the changelog titles and even add custom ones. To see configuration [go here](/auto/pages/autorc.html#changelog-titles).\n\n## Additional Release notes\n\nSometimes a PR title is just not enough to capture what a user should know about that PR. That's why we've included the ability to put extra release notes right in your PRs. All you have to do is add a `Release Notes` section in your PR.\n\nTake the following PR body:\n\n```md\n# What Changed\n\nChange `shipit` behavior.\n\n## Release Notes\n\n`auto shipit` will only ship to `latest` on the base branch ([which is configurable]()). If ran locally or from a PR it will create a `canary` release that doesn't interfere with your `latest` release.\n```\n\nThis will create a special section at the top of the changelog that collects all the additional release notes from merged PRs. Below is a sample of what it might look like.\n\n---\n\n# v5.0.0 (Sat May 04 2019)\n\n### Release Notes\n\n_From #371_\n\n`auto shipit` will only ship to `latest` on the base branch ([which is configurable]()). If ran locally or from a PR it will create a `canary` release that doesn't interfere with your `latest` release.\n\n---\n\n#### ðŸ’¥ Breaking Change\n\n- shipit will publish a canary locally when not on master [#371](https://github.com/intuit/auto/pull/371) ([@hipstersmoothie](https://github.com/hipstersmoothie))\n\n#### Authors: 1\n\n- Andrew Lisowski ([@hipstersmoothie](https://github.com/hipstersmoothie))\n"},{id:"pages/getting-started.md",body:'# Getting Started\n\nBefore we do anything we must first install `auto` as a dev dependency.\n\n```sh\nyarn add -D auto\n```\n\nIf you are using `auto` in a non-javascript project, you can install `auto` and all it\'s official plugins via the [releases](https://github.com/intuit/auto/releases) page. Here you will find a build of `auto` for all major OSes. This build has `node` bundled so you don\'t need it installed!\n\n::: message is-warning\n:warning: If you use `yarn@2` none of the default plugins (`npm` and `released`) are included so you must install them if you want to use them.\n:::\n\n## Help\n\nTo get detailed help for any command use the `--help` flag.\n\n```sh\nauto --help\n# or command help\nauto comment --help\n```\n\n### Make "Latest Release"\n\nIf your project is already published then you need to make sure that your last release is tagged and that it\'s the `Latest Release` on GitHub.\n\nTo tag your last release find that last commit where you bumped the version and run the following commands with your version number.\n\n```sh\ngit tag v1.2.3\ngit push --tags\n```\n\nThen on GitHub go to your project\'s releases and click `Draft a new release`. In the `Tag version` field enter the version number you just tagged and click `Publish release`.\n\nNow your github project is set up to use `auto`.\n\n## Configuration\n\nGetting started with `auto` is super easy.\n\n1. `auto init` (optional)\n2. Configure environment variables\n3. `auto create-labels`\n4. Set up script\n\n### 1. Initialize Options\n\nInitialize the bare minimum options and a few other optional things.\nThis will set you up locally but you will still have to configure environment variables in your CI.\n\n- Override default labels\n- Add additional labels\n- Add plugins\n- Creates an .env file for local testing\n\n### 2. Environment Variables\n\nYou must configure some environment variables for publishing and releasing to work properly.\n\n- `GH_TOKEN` - Used for publishing the GitHub release and creating labels ([create one here](https://github.com/settings/tokens)) (needs `repo` permission)\n- `NPM_TOKEN` - Used to publish to npm. (only with NPM plugin)\n\n::: message is-warning\nMake sure you give the `GH_TOKEN` `repo` permission or `shipit` will fail!\n:::\n\n#### Local `.env`\n\nYou can also store these values in a local file at the root of your project named `.env`. You should make sure to add this file to your `.gitignore` so you don\'t commit any keys! These env vars will override these any variable already set on the process. This enables you to have a per project configuration that isn\'t effected by your global setup.\n\n**`PROJECT_ROOT/.env`:**\n\n```bash\nGH_TOKEN=YOUR_TOKEN\nNPM_TOKEN=PUBLISH_TOKEN\n```\n\n#### HTTP Proxy\n\nIf you are running auto behind a `http` or `https` proxy, add either the `http_proxy` or `https_proxy` environment variable to your environment. To test locally add it to .env file. Remember this file is only local, so you will need to set the variable in your CI as well.\n\n```bash\nhttps_proxy=<PROXYHOST>:<PROXYPORT>\n```\n\n### 3. Labels\n\nAfter that, you need to set up the labels on your github project. The types of labels that `auto` uses are:\n\n- Versioning Labels - used to calculate version numbers and make releases. To change them refer to [this](/auto/pages/autorc.html#versioning-labels).\n- Changelog Labels - These labels do not effect the version calculation but they will change the section the PR displays in the changelog. These are customizable too, and you can even add your own sections. Read more [here](/auto/pages/autorc.html#changelog-titles)\n\nTo create the labels for your project on GitHub, run the following command with your `GH_TOKEN`.\n\n```sh\nGH_TOKEN=YOUR_TOKEN auto create-labels\n# or with .env file\nauto create-labels\n```\n\n### 4. Script\n\n`auto` is written so that each tool it exposes is useful in isolation. It also provides workflows for those who don\'t care about the details of each tool and just want their code released.\n\n#### Quick Setup (Recommended)\n\nTo version, changelog, publish and release your code all at the same time, we\'ve included the `shipit` tool.\nThis tool runs all commands in the default `auto` workflow and puts it into one meta-command.\nIt is context aware and will make different type of releases based on where you run it.\n[Read more here.](/auto/pages/generated/shipit.html)\n\n```json\n{\n  "scripts": {\n    "release": "auto shipit"\n  }\n}\n```\n\n#### Detailed Setup\n\nThe simplest workflow to get set up in just the `package.json` is by adding the following to your `package.json`. With this setup your application will not be able to use the `skip-release` flag, but everything else will work just fine\n\n```json\n{\n  "scripts": {\n    "version": "npm version `auto version` -m \'Bump version to: %s [skip ci]\'",\n    "publish": "npm publish && git push --follow-tags --set-upstream origin $branch",\n    "release": "auto changelog && npm run version && npm run publish && auto release"\n  }\n}\n```\n\n##### Enabling `skip-release` label\n\nTo use the `skip-release` label you have to get a little more involved and use a shell script. We could do the `if` checks in the `package.json`, but this would get messy and hard to read very quickly.\n\n```json\n{\n  "scripts": {\n    "release": "./scripts/release.sh"\n  }\n}\n```\n\nHere is an example release script for a single NPM package:\n\n```sh\nexport PATH=$(npm bin):$PATH\n\nVERSION=`auto version`\n\n## Support for label \'skip-release\'\nif [ ! -z "$VERSION" ]; then\n  ## Update Changelog\n  auto changelog\n\n  ## Publish Package\n  npm version $VERSION -m "Bump version to: %s [skip ci]"\n  npm publish\n\n  ## Create GitHub Release\n  git push --follow-tags --set-upstream origin $branch\n  auto release\nfi\n```\n\nor if you are using lerna to manage a monorepo.\n\n```sh\nexport PATH=$(npm bin):$PATH\n\nVERSION=`auto version`\n\nif [ ! -z "$VERSION" ]; then\n  auto changelog\n  lerna publish --yes $VERSION -m \'%v [skip ci]\'\n  auto release\nfi\n```\n\n## Enterprise\n\nIf you are using enterprise github `auto` lets you configure the github API URL that it uses. You can configure this by using the CLI option `--github-api`, by setting the value in your [.autorc](/auto/pages/autorc.html#githubApi), or during `auto init`.\n'},{id:"pages/generated/label.md",body:"# `label`\n\nGet the labels for a pull request. Doesn't do much, but the return value lets you write you own scripts based off of the PR labels!\n\n## Options\n\n| Flag | Type | Description |\n| - | - | - |\n| `--pr` | Number | The pull request the command should use. Detects PR number in CI (defaults to last merged PR) |\n\n## Examples\n\n```sh\nauto label --pr 123\n```\n\n\n## Using in scripts\n\nThe following will only run the test:visual script when the PR has has the  \n Visual label.\n\n```sh\nexport PATH=$(npm bin):$PATH\n\nif [ auto label --pr $PR_NUMBER | grep -c '^Visual' -ne 0 ];\nthen\n  npm run test:visual\nfi\n```\n\n## Without PR Number\n\nRunning `auto label` without the PR number will:\n\n- When run in master will get the labels for the last merged PR\n- When run for a PR in CI will use the PR's number\n"},{id:"pages/generated/init.md",body:"# Initialization\n\n`auto` provides some tools to quickly set up your project. If you do not want to use the interactive experience all these options can be configured via the [.autorc](/auto/pages/generated/autorc.html) and most can be configure via CLI options.\n### `init`\n\nInteractive setup for minimum working configuration.\n\n#### Examples\n\n```sh\nauto init\n```\n\n\n### `create-labels`\n\nCreate your project's labels on github. If labels exist it will update them.\n\n#### Options\n\n| Flag | Type | Description |\n| - | - | - |\n| `--dry-run`, `-d` | Boolean | Report what command will do but do not actually do anything |\n\n#### Examples\n\n```sh\nauto create-labels\n```\n\n\n::: message is-warning\n:warning: For this to work you must have a `GH_TOKEN` set, ex: `GH_TOKEN=YOUR_TOKEN auto create-labels`\n:::"},{id:"pages/generated/latest.md",body:'# `latest`\n\nRun the full `auto` release pipeline. Force a release to latest and bypass `shipit` safeguards.\n\n## Options\n\n| Flag | Type | Description |\n| - | - | - |\n| `--name` | String | Git name to commit  with. Defaults to package definition for the platform |\n| `--email` | String | Git email to commit with. Defaults to package definition for the platform |\n| `--only-publish-with-release-label` | Boolean | Only bump version if \'release\' label is on pull request |\n| `--base-branch` | String | Branch to treat as the "master" branch |\n| `--dry-run`, `-d` | Boolean | Report what command will do but do not actually do anything |\n| `--no-version-prefix` | Boolean | Use the version as the tag without the \'v\' prefix. WARNING: some plugins might need extra config to use this option (ex: npm) |\n| `--prerelease` | Boolean | Publish a prerelease on GitHub. |\n| `--title` | String | Override the title used in the addition to the CHANGELOG.md. |\n| `--message`, `-m` | String | Message to commit the changelog with. Defaults to \'Update CHANGELOG.md [skip ci]\' |\n| `--quiet`, `-q` | Boolean | Print **only** the result of the command |\n\n## Examples\n\n```sh\nauto latest\n```\n\n\n## Configurable Options\n\nYou can configure some of the options for the `latest` command in the `.autorc`.\n\n- `prerelease`\n- `message`\n\n**Example `.autorc`:**\n\n```json\n{\n  "latest": {\n    "prerelease": true,\n    "message": "string"\n  }\n}\n```'},{id:"pages/generated/pr-check.md",body:"# `pr-check`\n\nCheck that a pull request has a SemVer label\n\n## Options\n\n| Flag | Type | Description |\n| - | - | - |\n| `--pr` | Number | The pull request the command should use. Detects PR number in CI |\n| `--url` | String | URL to associate with this status |\n| `--dry-run`, `-d` | Boolean | Report what command will do but do not actually do anything |\n| `--context` | String | A string label to differentiate this status from others |\n\n## Examples\n\n```sh\nauto pr-check --url http://your-ci.com/build/123\n```\n\n"},{id:"pages/generated/pr-body.md",body:'# `pr-body`\n\nUpdate the body of a PR with a message. Appends to PR and will not overwrite user content. Each comment has a context, and each context only has one comment.\n\n## Options\n\n| Flag | Type | Description |\n| - | - | - |\n| `--pr` | Number | The pull request the command should use. Detects PR number in CI |\n| `--context` | String | A string label to differentiate this status from others |\n| `--message`, `-m` | String | Message to post to PR body |\n| `--dry-run`, `-d` | Boolean | Report what command will do but do not actually do anything |\n\n## Examples\n\n```sh\nauto pr-body --delete\n```\n\n```sh\nauto pr-body --pr 123 --comment "The new version is: 1.2.3"\n```\n\n'},{id:"pages/generated/next.md",body:'# `next`\n\nMake a release for your "prerelease" release line. This is ran automatically from "shipit".\n\n1. Creates a prerelease on package management platform\n2. Creates a "Pre Release" on GitHub releases page.\n\nCalling the `next` command from a prerelease branch will publish a prerelease, otherwise it will publish to the default prerelease branch.\n\n## Options\n\n| Flag | Type | Description |\n| - | - | - |\n| `--dry-run`, `-d` | Boolean | Report what command will do but do not actually do anything |\n| `--message`, `-m` | String | The message used when attaching the prerelease version to a PR |\n| `--quiet`, `-q` | Boolean | Print **only** the result of the command |\n\n## Examples\n\n```sh\nauto next\n```\n\n\n## Configurable Options\n\nYou can configure some of the options for the `next` command in the `.autorc`.\n\n- `message`\n\n**Example `.autorc`:**\n\n```json\n{\n  "next": {\n    "message": "string"\n  }\n}\n```\n### Setting up Protected Branches\n\nYou should make your pre-release branches protected on GitHub. This will prevent a bunch of unwanted behavior from happening.\n\n1. Go to you project\'s setting on [GitHub](https://github.com)\n2. Click `Branches`\n3. Click `Add Rule`\n4. Enter the name of your prerelease branch (ex: `next`)\n5. Configure extra branch protection settings\n6. (Optional) Set the base branch in GitHub to your prerelease branch (this ensure new PRs go to this branch)\n'},{id:"pages/generated/pr-status.md",body:"# `pr-status`\n\nSet the status on a PR commit\n\n## Options\n\n| Flag | Type | Description |\n| - | - | - |\n| `--sha` | String | Specify a custom git sha. Defaults to the HEAD for a git repo in the current repository |\n| `--pr` | Number | PR to set the status on. Detects PR number in CI |\n| `--url` | String | URL to associate with this status |\n| `--state` | String | State of the PR. ['pending', 'success', 'error', 'failure'] |\n| `--description` | String | A description of the status |\n| `--context` | String | A string label to differentiate this status from others |\n| `--dry-run`, `-d` | Boolean | Report what command will do but do not actually do anything |\n\n## Examples\n\n```sh\nauto pr \\\\ \n   --state pending \\\\ \n   --description \"Build still running...\" \\\\ \n   --context build-check\n```\n\n"},{id:"pages/generated/release.md",body:'# `release`\n\nAuto-generate a github release\n\n## Options\n\n| Flag | Type | Description |\n| - | - | - |\n| `--dry-run`, `-d` | Boolean | Report what command will do but do not actually do anything |\n| `--no-version-prefix` | Boolean | Use the version as the tag without the \'v\' prefix. WARNING: some plugins might need extra config to use this option (ex: npm) |\n| `--name` | String | Git name to commit  with. Defaults to package definition for the platform |\n| `--email` | String | Git email to commit with. Defaults to package definition for the platform |\n| `--from` | String | Git revision (tag, commit sha, ...) to start release notes from. Defaults to latest tag. |\n| `--use-version` | String | Version number to publish as. Defaults to reading from the package definition for the platform. |\n| `--base-branch` | String | Branch to treat as the "master" branch |\n| `--prerelease` | Boolean | Publish a prerelease on GitHub. |\n\n## Examples\n\n```sh\nauto release\n```\n\n```sh\nauto release --from v0.20.1 --use-version v0.21.0\n```\n\n\n## Configurable Options\n\nYou can configure some of the options for the `release` command in the `.autorc`.\n\n- `prerelease`\n\n**Example `.autorc`:**\n\n```json\n{\n  "release": {\n    "prerelease": true\n  }\n}\n```\n::: message is-warning\nMake sure you give the `GH_TOKEN` `repo` permission or `release` will fail!\n:::\n\n## Usage\n\n```json\n{\n  "scripts": {\n    "postpublish": "auto release"\n  }\n}\n```\n\nMake sure the branch/tag you\'re releasing is on github before running `auto release`.\nYou will need to push the tags to github first:\n\n```json\n{\n  "scripts": {\n    "postpublish": "git push --follow-tags --set-upstream origin $branch && auto release"\n  }\n}\n```\n\n## Github Release Details\n\nThe details / description published with the Github release will be identical to those generated by the `auto changelog` command.\nSee information regarding the release note format [here](/auto/pages/generated/changelog.html#changelog-titles).\n'},{id:"pages/generated/shipit.md",body:'# `shipit`\n\nContext aware publishing.\n\n1. call from base branch -> latest version released (LATEST)\n2. call from prerelease branch -> prerelease version released (NEXT)\n3. call from PR in CI -> canary version released (CANARY)\n4. call locally when not on base/prerelease branch -> canary version released (CANARY)\n\n## Options\n\n| Flag | Type | Description |\n| - | - | - |\n| `--name` | String | Git name to commit  with. Defaults to package definition for the platform |\n| `--email` | String | Git email to commit with. Defaults to package definition for the platform |\n| `--only-publish-with-release-label` | Boolean | Only bump version if \'release\' label is on pull request |\n| `--base-branch` | String | Branch to treat as the "master" branch |\n| `--dry-run`, `-d` | Boolean | Report what command will do but do not actually do anything |\n| `--no-version-prefix` | Boolean | Use the version as the tag without the \'v\' prefix. WARNING: some plugins might need extra config to use this option (ex: npm) |\n| `--prerelease` | Boolean | Publish a prerelease on GitHub. |\n| `--title` | String | Override the title used in the addition to the CHANGELOG.md. |\n| `--message`, `-m` | String | Message to commit the changelog with. Defaults to \'Update CHANGELOG.md [skip ci]\' |\n| `--quiet`, `-q` | Boolean | Print **only** the result of the command |\n| `--only-graduate-with-release-label` | Boolean | Make auto publish prerelease versions when merging to master. Only PRs merged with "release" label will generate a "latest" release. Only use this flag if you do not want to maintain a prerelease branch, and instead only want to use master. |\n\n## Examples\n\n```sh\nauto shipit\n```\n\n\n## Configurable Options\n\nYou can configure some of the options for the `shipit` command in the `.autorc`.\n\n- `prerelease`\n- `message`\n- `only-graduate-with-release-label`\n\n**Example `.autorc`:**\n\n```json\n{\n  "shipit": {\n    "prerelease": true,\n    "message": "string",\n    "only-graduate-with-release-label": true\n  }\n}\n```\n## Release Pipeline\n\nBelow is the basics steps auto takes when releasing your code through the `shipit` command.\n\n![The default shipit workflow](../../images/default-auto.png)\n\nYou can customize how this pipeline operates with various flags.\nThe following shows how those flags can effect the workflow.\n\n![The entire shipit workflow](../../images/complete-auto.png)\n\n## Managing Old Major Versions\n\nThis command also has the ability to help you manage old major versions too!\nThis feature is off by default, to enable set `versionBranches` to `true` in your [.autorc](/auto/pages/autorc.html#versionbranches).\n\nWith this feature enabled `auto shipit` will:\n\n- Create a version branch when a `major` happens (prefixed with `version-`)\n- When ran from a `versionBranch` make a release to that version\n\nNow that you have a branch for an old major release, it is super easy to release patches to it!\nPeople can make PRs to the the `version-` branch and once merged create a new release of that version.\n\n### Customize Branch Prefix\n\nYou can customize what the branch names will be by setting `versionBranches` to a string.\n\n```json\n{\n  "versionBranches": "Major-"\n}\n```\n\n## Prereleases\n\nIf you are interested in pre-releases (ex: `alpha`, `beta`, `next`) `auto` has the ability to publish pre-releases in various ways.\n\nRead more about preparing you project for pre-releases [here](/auto/pages/generated/next.html#setting-up-protected-branches).\n\n### Strategies\n\n#### "next" Branch (default)\n\nThe suggested way to create pre-releases is by managing 2 branches for your repo: `master` and `next`.\n`master` contains the `latest` stable version of the code, and `next` contains future updates.\n\nYou can change what branches `auto` treats as pre-release branches in your [`.autorc`](/auto/pages/autorc.html#prerelease-branches).\n\n![Example git tree](../../images/next-branch.png)\n\nTo update the `latest` stable version simply merge your pre-release branch into your `baseBranch`.\n\n#### Without "next" Branch (`--only-graduate-with-release-label`)\n\nIf you use the `--only-graduate-with-release-label` flag, you do not have to manage 2 branches.\nInstead you only have a `baseBranch` and do all work and pull requests there.\n`auto` will only publish pre-releases when PRs are merged.\nTo update the `latest` stable version add the `released` label to the PR.\n\nWhile this setup may be simpler, it restricts you from updating latest while development is happening for the pre-release.\nWith 2 branches you can easily merge update to the latest release, with 1 this is not possible.\n\n#### Multiple "next" Branches\n\nSometimes you might want to have more rigorous release lines.\nThis can help test out bugs on a smaller set of users.\n\nOne setup you could use to accomplish this is by creating 3 `prereleaseBranches`\n\n```json\n{\n  "prereleaseBranches": ["alpha", "beta", "rc"]\n}\n```\n\nYou could then set you default to `alpha` and `auto` would publish updates merged to that branch under the `alpha` release tag.\nWhen you are ready for the update to get used by more users just merge `alpha` into `beta`.\nThis will publish a `beta` release to the matching release tag.\nRepeat this same process when graduating to `rc` or `latest`.\n\n#### Feature Pre-releases\n\nSometimes you are working on a large feature that requires a lot of work.\nInstead of making a giant PR with a bunch of updates, you can create a `prereleaseBranch` to track the work.\n\n```json\n{\n  "prereleaseBranches": ["next", "my-cool-feature"]\n}\n```\n\nNow instead of just getting a canary version when merging into the `my-cool-feature` branch, a prerelease version is published under the `my-cool-feature` release tag!\nThis enables other to consume just this line of work and enables your work to be more flexible.\n'},{id:"pages/generated/version.md",body:"# `version`\n\nGet the semantic version bump for the given changes. Requires all PRs to have labels for the change type. If a PR does not have a label associated with it, it will default to `patch`.\n\n## Options\n\n| Flag | Type | Description |\n| - | - | - |\n| `--only-publish-with-release-label` | Boolean | Only bump version if 'release' label is on pull request |\n| `--from` | String | Git revision (tag, commit sha, ...) to calculate version bump from. Defaults to latest github release |\n\n## Examples\n\nGet the new version using the last release to head\n\n ```sh\nauto version\n```\n\n\nUseful in conjunction with `npm version` to auto-version releases.\n\n## Configure Versioning Labels\n\nYou can customize the versioning labels in the `.autorc`. To see configuration [go here](/auto/pages/generated/autorc.html#versioning-labels).\n"},{id:"pages/introduction.md",body:"![Markdown](../images/auto.gif)/.header-image\\\n\n# :rocket: auto :rocket:/.has-text-centered\\\n\n> Automated releases powered by pull request labels\n\nStreamline your release workflow and publish constantly!\n`auto` is meant to be run in a continuous integration (CI) environment, but all the commands work locally as well.\n\nThe two main problems auto is trying to solve are: release automation and pull request interaction.\nWith the set of tools we provide you can automate every part of contribution!\n\n<br />\n\n**Release Features:**\n\n- Calculate semantic version bumps from PRs\n- Publish [canaries](/auto/pages/generated/canary.html) (test versions) directly from PRs or locally\n- Generate changelogs with fancy headers, authors, and [detailed release notes](/auto/pages/generated/changelog.html#additional-release-notes)\n- Make GitHub releases\n\n**Pull Request Interaction Features:**\n\n- Get the labels for a PR\n- Set the status of a PR\n- Comment on a PR with markdown\n- Update the PR body with contextual build metadata\n"},{id:"pages/non-npm.md",body:'# Non-npm Usage\n\n`auto` is typically distributed through [npm](https://npmjs.com) but you can use it with a variety of package management platforms.\n\n## Installation\n\nIf you\'re on some platform other than [npm](https://npmjs.com) it doesn\'t make sense to download `auto` through [npm](https://npmjs.com).\nFor these situations we package `auto` for all major operating systems (`linux`, `osx`, `windows`).\n\nSimply download the appropriate version for your operating system and make it executable.\n\n```sh\n# Download a platform specific version of auto\ncurl -vkL -o - https://github.com/intuit/auto/releases/download/v7.2.0/auto-linux.gz | gunzip > ~/auto\n# Make auto executable\nchmod a+x ~/auto\n```\n\nThis executable contains all of the official `auto` plugins so you do not have to download anything extra.\nThis version of `auto` uses the [git-tag](/auto/plugins/git-tag/README.html) plugins as the default instead of [npm](/auto/plugins/npm/README.html).\nIf you specify any plugins this will be overridden.\n\n### Installation via brew (OSX)\n\nIf you are on OSX you can install `auto` with brew.\n\n```sh\nbrew tap intuit/auto https://github.com/intuit/auto\nbrew install auto\n```\n\n## Configuration\n\nTo configure `auto` to work with your project you will need to do two things\n\n1. Create and configure a [`GH_TOKEN`](https://github.com/settings/tokens) environment variable\n2. Create an `.autorc` for your project\n\n### Making an `.autorc`\n\nUsing `auto` with any other package manager than [npm](https://npmjs.com) requires that you create an [`.autorc`](/auto/pages/autorc.html) at the root of your project.\n\n1. `.autorc` - No plugins, `shipit` doesn\'t work. Enables [advanced setup](https://intuit.github.io/auto/pages/getting-started.html#detailed-setup)\n\n   ```json\n   {\n     "name": "Andrew Lisowski",\n     "email": "lisowski54@gmail.com",\n     "plugins": []\n   }\n   ```\n\n2. `.autorc` - `git-tag` plugin compatible with any platform. Enables [`shipit` usage](https://intuit.github.io/auto/pages/generated/shipit.html)\n\n   ```json\n   {\n     "name": "Andrew Lisowski",\n     "email": "lisowski54@gmail.com",\n     "plugins": ["git-tag"]\n   }\n   ```\n\n3. `.autorc` - With package manager plugin. [`shipit`](https://intuit.github.io/auto/pages/generated/shipit.html) works, some configuration picked up from package manager package definition files. In the following `repo`, `owner`, `name`, and `email` are picked up from the `pom.xml`\n\n   ```json\n   {\n     "plugins": ["maven"]\n   }\n   ```\n\n## Usage\n\nNow that you have `auto` all set up you can use all of it\'s commands!\n\n```sh\n~/auto shipit\n```\n\n::: message is-info\nâ„¹ï¸ Tip: Using `auto` locally with an `.env` file is a great experience. See how [here](./getting-started.md#local-.env).\n:::\n\n## Plugins\n\nAs stated above, all of the official plugins (the ones included in this repo/docs) are included in the binary version of `auto`.\nHowever you might want to use an unofficial plugin or even write your own.\n\n#### Local Plugins\n\nOne way to use unofficial plugins in a non-javascript project is to have a directory committed to your project where you store them.\n\nYou could:\n\n- Write your own custom plugins and store them in here\n- Copy a plugin from the internet\n\n**`.autorc`:**\n\n```json\n{\n  "plugins": ["./plugins/custom-plugin.js"]\n}\n```\n\n#### Hosted Plugins\n\nIf you want to share your custom plugins between projects then you can host them on some SCM (ex: GitHub).\nA plugin just needs to consist of an `index.js` that implements your plugin. (or it could be as complex as any NPM package)\n\nEdit your CI build to download these plugins when building.\n\n```sh\nmkdir plugins\ngit clone https://github.com/me/custom-plugin plugins/custom-plugin\n```\n\n**`.autorc`:**\n\n```json\n{\n  "plugins": ["./plugins/custom-plugin"]\n}\n```\n\n#### NPM Plugins\n\nIf distributed via NPM you could install those plugins globally through `npm`:\n\n```sh\nnpm i -g auto-plugin-my-custom-plugin\n```\n\n**`.autorc`:**\n\n```json\n{\n  "plugins": ["my-custom-plugin"]\n}\n```\n'},{id:"pages/plugins.md",body:'# Plugins\n\n`auto` uses the package [tapable](https://github.com/webpack/tapable) to expose a plugin system. Go [here](/auto/pages/writing-plugins.html) to learn how to write one!\n\n## Using Plugins\n\nTo use a plugin you can either supply the plugin via a CLI arg or in your [.autorc](/auto/pages/autorc.html#plugins).\n\n::: message is-warning\n:warning: Specifying a plugin overrides the defaults.\n:::\n\n### Defaults\n\nIf you don\'t configure plugins in your `.autorc` configuration file `auto` will use a default package manager plugin.\n\n- Installed through `npm` => uses [`npm`](/auto/plugins/npm/README.html)\n- Installed through executable => uses [`git-tag`](/auto/plugins/git-tag/README.html)\n\n### No Plugins\n\nIf you don\'t want to include the default plugins, you can supply an empty array in the `.autorc` configuration file like the following:\n\n```js\n{\n  "plugins": []\n}\n```\n\n## Plugin Declaration\n\nThere are three ways to name and use a plugin.\n\n### Official Plugins\n\nTo use an official plugin all you have to do is supply the name.\n\n```js\n{\n  "plugins": [\n    "npm",\n    // or the full name\n    "@auto-it/npm"\n  ]\n}\n```\n\n### `npm` package\n\nUnofficial plugins pulled from NPM should be named in one of the following formats:\n\n- `auto-plugin-PLUGIN_NAME`\n- `@my-scope/auto-plugin-PLUGIN_NAME`\n\nYou use them in your `.autorc` by:\n\n- provide the full package name\n- when named like `auto-plugin-PLUGIN_NAME` just the `PLUGIN_NAME`.\n\n```js\n{\n  "plugins": [\n    "my-cool-plugin",\n    // or\n    "auto-plugin-my-cool-plugin",\n    // on a scope\n    "@my-scope/auto-plugin-my-cool-plugin",\n  ]\n}\n```\n\n### Local Plugin\n\nOr if you have a plugin locally supply the path.\n\n```js\n{\n  "plugins": ["../path/to/plugin.js"]\n}\n```\n\n## Plugin Configuration\n\nTo provide plugin specific config change the following:\n\n```js\n{\n  "plugins": ["chrome"]\n}\n```\n\nTo this:\n\n```js\n{\n  "plugins": [\n    ["chrome", { "extensionId": "1234", "build": "my-compiled-extension.zip" }]\n  ]\n}\n```\n'},{id:"pages/publishing.md",body:'# Publishing\n\n`auto`\'s main use it to automate the release process for your project. This can be broken down into three core steps:\n\n```text\npre: (optional) Check if new version\n\n1. Generate CHANGELOG.md\n2. Publish code\n3. Generate github release notes\n```\n\n`auto` makes no assumptions about your publishing process. Each tool is a function that can be run in isolation and only does one thing really well. For instance, you could just use `auto changelog` to generate the changelog and nothing else or use `auto version` to calculate just the semver bump.\n\n## Base Branch\n\nBy default `auto` assumes that your repo\'s base branch is `master`. You can configure this behavior through the [.autorc](/auto/pages/autorc.html#base-branch) or via a CLI to any relevant command.\n\n```sh\nauto shipit --base-branch trunk\n```\n\n## Push to base branch\n\nIf you push commits to the base branch they will count as patches. This is a good way to get a release out without having to make a PR.\n\nThe changelog entry will contain the first line of the commit message. These commits will fall under a special section in the changelog.\n\nex:\n\n```md\nâš ï¸ Pushed to master\n\n- fix docs publishing ([@lisowski54@gmail.com](https://github.com/lisowski54@gmail.com))\n```\n\nYou can configure the title of this changelog entry by adding the `pushToBaseBranch` label in your config.\n\n```json\n{\n  "labels": [\n    {\n      "name": "pushToBaseBranch",\n      "changelogTitle": "Emergency!!"\n    }\n  ]\n}\n```\n'},{id:"pages/quick-merge.md",body:'# Merging Quickly\n\nOne caveat of `auto` is that you need to be mindful of merging multiple PRs at once. You **must not** merge a PR while another is publishing (ex: `lerna publish`). While this window is small, it exists and you should know about it.\n\n`auto` works by looking at the `git` tree to calculate the version bump then makes commits for the `CHANGELOG.md` and the new version. If you merge a PR while another is publishing:\n\n- they might try to publish the same version number\n- one will try to push over the other\'s changes and fail\n\n::: message is-success\nIf you ensure that the last build on master has finished you shouldn\'t run into any problems!\n:::\n\n## With `skip-release`\n\nThe one exception to this rule with when merging a bunch of PRs with `skip-release` labels.\n\nYou still can\'t merge a PR that triggers a release and then merge a PR with `skip-release`. This will result in problem 3 from above.\n\n```txt\n1. Merge PR #4 "patch"\n2. Merge PR #5 "skip-release"\n\nResult: #4 tries to push commits over #5 and fails\n```\n\nBut you can merge a bunch of PRs with `skip-release` then merge a PR that triggers a release.\n\n```txt\n1. Merge PR #4 "skip-release"\n2. Merge PR #5 "skip-release"\n3. Merge PR #7 "patch"\n\nResult: 1 "patch" released w/all PRs\n```\n\nBecause `skip-release` is present no commits are made and the release is fine!\n'},{id:"pages/troubleshooting.md",body:"# Troubleshooting\n\n## Error: Can't find a GitHub token to use\n\nYou must set a [`GH_TOKEN`](https://github.com/settings/tokens) for `auto` to work. If you publish to npm make sure to add your `NPM_TOKEN` while you're at it as well.\n\n## Working directory not clean\n\nTo version and publish you cannot have any changes in the git repo during publish. This means that if you build some files before release that aren't git-ignored `auto` will fail to continue. To fix this either add those `dist` files to your `.gitignore` or commit them somehow before the release.\n\n## You cannot publish over the previously published versions\n\nIf you've encountered any of these errors you'll probably run into this problem. If the whole release process doesn't complete you can end up in a state when `auto` published the new version, but doesn't push that back to github. To fix this just bump the version number to the \"previously published version\".\n\n## How do I auto a fork of another repo?\n\nIf auto doesn't find a last release it will default to the first commit for version calculation (and a log of other things). If you have forked a repo, you fork all the merge commit messages as well. This confuses `auto` since it will look for those pull requests in your fork and not the main one.\n\nTo remedy this first tag your first commit in the fork with your first version. If the tags from the original repo are still in your repo you should just bump that version. This will let `auto` ignore all the old merge commits.\n\n::: message is-warning\n:warning: You must also match this new tag version in your package.json\n:::\n\n```sh\n# Set head to last release and tag it with 2.10.1\ngit tag v2.10.1\n```\n\nThen on GitHub go to your project, click release, then draft a new release. Select the tag you just published and `publish release`. Now auto will be able to use the correct version and git log!\n"}];n.default=o,e.exports=n.default}}]);
//# sourceMappingURL=search-files.js.map